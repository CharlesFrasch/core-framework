/*
 * This file is protected by Copyright. Please refer to the COPYRIGHT file
 * distributed with this source distribution.
 *
 * This file is part of REDHAWK bulkioInterfaces.
 *
 * REDHAWK bulkioInterfaces is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * REDHAWK bulkioInterfaces is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses/.
 */

#ifndef __bulkio_datablock_h
#define __bulkio_datablock_h

#include <list>
#include <complex>

#include <boost/shared_ptr.hpp>

#include <BULKIO/bulkioDataTypes.h>

namespace bulkio {

  /**
   * @brief  Extended time stamp container.
   *
   * SampleTimestamp adds additional context to a BULKIO::PrecisionUTCTime
   * time stamp. When data is read from an InputStream, it may span more than
   * one packet, or its start may not be on a packet boundary. In these cases,
   * the @a offset and @a synthetic fields allow more sophisticated handling
   * of time information.
   *
   * The @a offset indicates at which sample @a time applies. If the sample
   * data is complex, @a offset should be interpreted in terms of complex
   * samples (i.e., two real values per index).
   *
   * A %SampleTimestamp is considered synthetic if it was generated by an
   * %InputStream because there was no received time stamp available at that
   * sample offset. This occurs when the prior read did not end on a packet
   * boundary; only the first time stamp in a DataBlock can be synthetic.
   */
  struct SampleTimestamp
  {
    /**
     * @brief  Constructor.
     * @param time  Time stamp.
     * @param offset  Sample offset.
     * @param synthetic  False if @p time was received, true if interpolated.
     */
    SampleTimestamp(const BULKIO::PrecisionUTCTime& time, size_t offset=0, bool synthetic=false) :
      time(time),
      offset(offset),
      synthetic(synthetic)
    {
    }

    /// @brief  The time at which the referenced sample was created.
    BULKIO::PrecisionUTCTime time;

    /// @brief  The 0-based index of the sample at which @a time applies.
    size_t offset;

    /// @brief  Indicates whether @a time was interpolated.
    bool synthetic;
  };

  /**
   * @brief  Container for sample data and stream metadata read from an
   *         InputStream.
   * @headerfile  bulkio_datablock.h <bulkio/bulkio_datablock.h>
   *
   * %DataBlock is a smart pointer-based class that encapsulates the result of
   * a single-read operation on an InputStream. It includes both sample data,
   * which may be real or complex, and metadata, which includes signal-related
   * information (SRI).
   *
   * @warning  Do not declare instances of this template class directly in user
   *           code; the template parameter and class name are not considered
   *           API. Use the type-specific @c typedef instead, such as
   *           bulkio::FloatDataBlock, or the nested @c typedef BlockType from
   *           an %InputStream.
   *
   * DataBlocks have reference semantics; in other words, assigning one block
   * to another does not make a copy but rather shares the same sample data
   * and metadata. When the last reference expires, the memory is released to
   * the system to prevent memory leaks. Additionally, blocks are inexpensive
   * to return by value, reassign, or store in nested data types.
   *
   * The default constructor creates an invalid or "null" block. Likewise,
   * %InputStream read operations may return an invalid block if the operation
   * cannot be completed. When receiving a data block, you must always check
   * for validity before accessing the sample data or metadata:
   * @code
   *   if (!block) {
   *     // handle failure
   *   } else {
   *     // access data and metadata
   *   }
   * @endcode
   *
   * While it is possible to generate DataBlocks in user code, they are usually
   * obtained by reading from an %InputStream.
   * @see  InputStream::read
   * @see  InputStream::tryread
   *
   * @par  Real vs. Complex Samples
   * Because BulkIO streams support both real and complex sample data, blocks
   * store data internally as an array of real samples, thus providing methods that
   * allow the user to interpret the data as either real or complex. When the
   * complex mode changes, this is typically indicated with the corresponding
   * SRI change flag (see sriChangeFlags()). On a per-block basis, the complex()
   * method indicates whether the sample data is intended to be handled as real
   * or complex:
   * @code
   *   if (block.complex()) {
   *     const float* cxdata = block.cxdata();
   *     for (size_t index = 0; index < block.cxsize(); ++index) {
   *       // do something with cxdata[index]
   *     }
   *   } else {
   *     const float* data = block.data();
   *     for (size_t index = 0; index < block.size(); ++index) {
   *       // do something with data[index]
   *     }
   *   }
   * @endcode
   */
  template <class T>
  class DataBlock
  {
  public:
    /// @brief  The native type of a real sample.
    typedef T ScalarType;

    /// @brief  The native type of a complex sample.
    typedef std::complex<T> ComplexType;

    /**
     * @brief  Default constructor.
     * @see  InputStream::read
     * @see  InputStream::tryread
     *
     * Create a null block. This block has no data nor metadata associated with
     * it. No methods may be called on a null %DataBlock except for operator!,
     * which will always return true, and operator==, which returns true if the
     * other %DataBlock is also null, or false otherwise.
     *
     * DataBlocks are typically obtained by reading from an InputStream.
     */
    DataBlock();

    /**
     * @brief  Construct a %DataBlock, optionally allocating buffer space.
     * @param sri  The SRI that describes the data.
     * @param size  Number of samples to allocate.
     *
     * Creates a new, valid block providing enough allocated space to hold @a size real
     * samples in the internal buffer. If the data is complex, @a size must be
     * twice the desired number of complex samples.
     *
     * @note  This method is typically called by InputStream.
     */
    DataBlock(const BULKIO::StreamSRI& sri, size_t size=0);

    /**
     * @brief  Copies this block's data and metadata.
     * @returns  A new block.
     *
     * Makes a complete copy of this block, which returns a unique block that does
     * not share this block's data or metadata.
     *
     * If this block is invalid, returns a new null block.
     */
    DataBlock copy() const;

    /**
     * @brief  Gets the stream metadata.
     * @returns  Read-only reference to stream SRI.
     * @pre  Block is valid.
     *
     * The SRI represents the stream metadata at the time the block was read.
     */
    const BULKIO::StreamSRI& sri() const;

    /**
     * @brief  Gets the X-axis delta.
     * @returns  The distance between two adjacent samples in the X direction.
     * @pre  Block is valid.
     *
     * Because the X-axis is commonly in terms of time (that is, @c sri.xunits is
     * @c BULKIO::UNITS_TIME), this is typically the reciprocal of the sample
     * rate.
     */
    double xdelta() const;

    /**
     * @brief  Read/write access to real sample data.
     * @returns  Pointer to first element as a real sample.
     * @pre  Block is valid.
     * @see  size()
     * @see  cxdata()
     *
     * Inteprets the internal buffer as real samples. Up to size() samples may
     * be accessed via the returned pointer.
     *
     * To interpret the data as complex samples, use cxdata().
     */
    ScalarType* data();

    /**
     * @brief  Read-only access to real sample data.
     * @returns  Const pointer to first element as a real sample.
     * @pre  Block is valid.
     * @see  size()
     * @see  cxdata() const
     *
     * Inteprets the internal buffer as real samples. Up to size() samples may
     * be accessed via the returned pointer.
     *
     * To interpret the data as complex samples, use cxdata() const.
     */
    const ScalarType* data() const;

    /**
     * @brief  Gets the size of the data in terms of real samples.
     * @returns  Number of real samples.
     * @see  cxsize()
     */
    size_t size() const;

    /**
     * @brief  Resizes the sample data buffer.
     * @param count  Number of scalar samples.
     * @pre  Block is valid.
     *
     * Adjusts the size of the internal buffer to hold @a count scalar samples.
     * If the data is complex, @a count should be twice the number of complex
     * samples.
     *
     * @warning  Use of this method is discouraged.
     */
    void resize(size_t count);

    /**
     * @brief  Checks whether data should be interpreted as complex samples.
     * @returns  True if data is complex. False if data is real.
     * @pre  Block is valid.
     *
     * The sample data is considered complex if @c sri.mode is non-zero.
     *
     * If the data is complex, the offsets for the time stamps returned by
     * getTimestamps() are in terms of complex samples.
     */
    bool complex() const;

    /**
     * @brief  Read/write access to complex sample data.
     * @returns  Pointer to first element as a complex sample.
     * @pre  Block is valid.
     * @see  cxsize()
     * @see  data()
     *
     * Inteprets the internal buffer as complex samples. Up to cxsize() samples
     * may be accessed via the returned pointer.
     *
     * To interpret the data as real samples, use data().
     */
    ComplexType* cxdata();

    /**
     * @brief  Read-only access to complex sample data.
     * @returns  Const pointer to first element as a complex sample.
     * @pre  Block is valid.
     * @see  cxsize()
     * @see  data() const
     *
     * Inteprets the internal buffer as complex samples. Up to cxsize() samples
     * may be accessed via the returned pointer.
     *
     * To interpret the data as real samples, use data() const.
     */
    const ComplexType* cxdata() const;

    /**
     * @brief  Gets the size of the data in terms of complex samples.
     * @returns  Number of complex samples.
     * @pre  Block is valid.
     * @see  size()
     */
    size_t cxsize() const;

    /**
     * @brief  Checks whether the SRI has changed since the last read from the
     *         same stream.
     * @returns  True if the SRI has changed. False is SRI is unchanged.
     * @pre  Block is valid.
     * @see  sriChangeFlags()
     */
    bool sriChanged() const;

    /**
     * @brief  Checks which SRI fields have changed since the last read from
     *         the same stream.
     * @returns  Bit mask representing changed fields.
     * @pre  Block is valid.
     * @see  sriChanged()
     *
     * If no SRI change has occurred since the last read, the returned value is
     * @c bulkio::sri::NONE (equal to 0). Otherwise, the returned value is the
     * bitwise OR of one or more of the following flags:
     *   @li @c bulkio::sri::HVERSION
     *   @li @c bulkio::sri::XSTART
     *   @li @c bulkio::sri::XDELTA
     *   @li @c bulkio::sri::XUNITS
     *   @li @c bulkio::sri::SUBSIZE
     *   @li @c bulkio::sri::YSTART
     *   @li @c bulkio::sri::YDELTA
     *   @li @c bulkio::sri::YUNITS
     *   @li @c bulkio::sri::MODE
     *   @li @c bulkio::sri::STREAMID
     *   @li @c bulkio::sri::BLOCKING
     *   @li @c bulkio::sri::KEYWORDS
     *
     * The @c HVERSION and @c STREAMID flags are not set in normal operation.
     */
    int sriChangeFlags() const;

    /**
     * @brief  Sets the flags for which SRI fields have changed since the
     *         last read from the same stream.
     * @param flags  Bit mask representing changed fields.
     * @pre  Block is valid.
     * @see  sriChangeFlags()
     *
     * @note  This method is typically called by InputStream.
     */
    void sriChangeFlags(int flags);

    /**
     * @brief  Checks whether the input queue has flushed since the last read.
     * @returns  True if an input queue flush occurred. False if no flush has occurred.
     * @pre  Block is valid.
     *
     * An input queue flush indicates that the InPort was unable to keep up
     * with incoming packets for non-blocking streams and emptied the queue
     * to catch up.
     *
     * The %InPort reports a flush once, on the next queued packet. This is
     * typically reflected in the next %DataBlock read from any InputStream
     * associated with the port; however, this does not necessarily mean that
     * any packets for that %InputStream were discarded.
     */
    bool inputQueueFlushed() const;

    /**
     * @brief  Set the input queue flush flag.
     * @param flush  True if an input queue flush occurred. False if no flush has occurred.
     * @pre  Block is valid.
     * @see  inputQueueFlushed()
     *
     * @note  This method is typically called by InputStream.
     */
    void inputQueueFlushed(bool flush);

    /**
     * @brief  Add a time stamp in sorted order.
     * @param timestamp  The new time stamp.
     * @pre  Block is valid.
     *
     * Inserts @a timestamp into the list of timestamps, sorted in sample
     * offset order.
     *
     * If complex() is true, @a timestamp.offset is interpreted in terms of
     * complex samples.
     *
     * @note  No validity checks are performed on @a timestamp.
     */
    void addTimestamp(const SampleTimestamp& timestamp);

    /**
     * @brief  Returns the time stamps for the sample data.
     *
     * If complex() is true, the offsets of the returned time stamps should be
     * interpreted in terms of complex samples.
     *
     * Valid %DataBlocks obtained by reading from an InputStream are guaranteed
     * to have at least one time stamp, at offset 0. If the read spanned more
     * than one packet, each packet's time stamp is included with the packet's
     * respective offsets from the first sample.
     *
     * When the %DataBlock is read from an %InputStream, only the first time
     * stamp may be synthetic. This occurs when the prior read did not consume
     * a full packet worth of data. In this case, the %InputStream linearly
     * interpolates the time stamp based on the stream's xdelta value.
     *
     * @note  The list is returned as a temporary value. If you plan to iterate
     *        through the returned list, it must be stored in a local variable.
     */
    std::list<SampleTimestamp> getTimestamps() const;

    /**
     * @brief  Calculates the difference between the expected and actual value
     *         of the last time stamp
     * @returns  Difference, in seconds, between expected and actual value.
     * @pre  Block is valid.
     * @see  getMaxTimeDrift()
     * @see  xdelta()
     *
     * If this %DataBlock contains more than one time stamp, this method
     * compares the last time stamp to a linearly interpolated value based on
     * the initial time stamp, the StreamSRI xdelta, and the sample offset.
     * This difference gives a rough estimate of the deviation between the
     * nominal and actual sample rates over the sample period.
     *
     * @note  If the SRI X-axis is not in units of time, this value has no
     *        meaning.
     */
    double getNetTimeDrift() const;

    /**
     * @brief  Calculates the largest difference between expected and actual
     *         time stamps in the block.
     * @returns  Greatest difference, in seconds, between expected and actual
     *           time stamps.
     * @pre  Block is valid.
     * @see  getNetTimeDrift()
     * @see  xdelta()
     *
     * If this %DataBlock contains more than one time stamp, this method
     * compares each time stamp to its linearly interpolated equivalent time
     * stamp, based on the initial time stamp, the StreamSRI xdelta, and
     * the sample offset. The greatest deviation is reported; this difference
     * gives a rough indication of how severely the actual sample rate deviates
     * from the nominal sample rate on a packet-to-packet basis.
     *
     * @note  If the SRI X-axis is not in units of time, this value has no
     *        meaning.
     */
    double getMaxTimeDrift() const;

    /**
     * @brief  Checks block validity.
     * @returns  True if this block is invalid. False if the block is valid.
     *
     * Invalid (null) blocks do not contain any sample data or metadata. An
     * InputStream read operation may return a null block if there is no data
     * available or the operation is interrupted.
     *
     * If this method returns true, no other methods except comparison or
     * assignment may be called.
     */
    bool operator! () const
    {
      return !_impl;
    }

    /**
     * @brief  Swaps the internal buffer with a vector.
     * @param other  Vector of real samples with which to swap.
     * @pre  Block is valid.
     *
     * Exchanges the sample data in the internal buffer with that of @a other.
     *
     * @warning  Use of this method is discouraged.
     */
    void swap(std::vector<ScalarType>& other);
  private:
    /// @cond IMPL
    struct Impl;
    boost::shared_ptr<Impl> _impl;
    /// @endcond IMPL
  };

  typedef DataBlock<int8_t>           CharDataBlock;
  typedef DataBlock<CORBA::Octet>     OctetDataBlock;
  typedef DataBlock<CORBA::Short>     ShortDataBlock;
  typedef DataBlock<CORBA::UShort>    UShortDataBlock;
  typedef DataBlock<CORBA::Long>      LongDataBlock;
  typedef DataBlock<CORBA::ULong>     ULongDataBlock;
  typedef DataBlock<CORBA::LongLong>  LongLongDataBlock;
  typedef DataBlock<CORBA::ULongLong> ULongLongDataBlock;
  typedef DataBlock<CORBA::Float>     FloatDataBlock;
  typedef DataBlock<CORBA::Double>    DoubleDataBlock;

}  // end of bulkio namespace

#endif
