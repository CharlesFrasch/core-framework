#!/usr/bin/env python
#
# This file is protected by Copyright. Please refer to the COPYRIGHT file 
# distributed with this source distribution.
# 
# This file is part of REDHAWK core.
# 
# REDHAWK core is free software: you can redistribute it and/or modify it under 
# the terms of the GNU Lesser General Public License as published by the Free 
# Software Foundation, either version 3 of the License, or (at your option) any 
# later version.
# 
# REDHAWK core is distributed in the hope that it will be useful, but WITHOUT 
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
# 
# You should have received a copy of the GNU Lesser General Public License 
# along with this program.  If not, see http://www.gnu.org/licenses/.
#


#
# Generated Thu Nov  4 15:01:55 2010 by generateDS.py version 1.17d.REDHAWK.
#

import sys
import getopt
from string import lower as str_lower
from xml.dom import minidom
from xml.dom import Node

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper:
        def format_string(self, input_data, input_name=''):
            return input_data
        def format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def format_boolean(self, input_data, input_name=''):
            return '%s' % input_data


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class _MemberSpec(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type(self): return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


#
# Data representation classes.
#

class softwareassembly(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id_=None, name=None, description=None, componentfiles=None, partitioning=None, assemblycontroller=None, connections=None, externalports=None):
        self.id_ = id_
        self.name = name
        self.description = description
        self.componentfiles = componentfiles
        self.partitioning = partitioning
        self.assemblycontroller = assemblycontroller
        self.connections = connections
        self.externalports = externalports
    def factory(*args_, **kwargs_):
        if softwareassembly.subclass:
            return softwareassembly.subclass(*args_, **kwargs_)
        else:
            return softwareassembly(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_componentfiles(self): return self.componentfiles
    def set_componentfiles(self, componentfiles): self.componentfiles = componentfiles
    componentfilesProp = property(get_componentfiles, set_componentfiles)
    def get_partitioning(self): return self.partitioning
    def set_partitioning(self, partitioning): self.partitioning = partitioning
    partitioningProp = property(get_partitioning, set_partitioning)
    def get_assemblycontroller(self): return self.assemblycontroller
    def set_assemblycontroller(self, assemblycontroller): self.assemblycontroller = assemblycontroller
    assemblycontrollerProp = property(get_assemblycontroller, set_assemblycontroller)
    def get_connections(self): return self.connections
    def set_connections(self, connections): self.connections = connections
    connectionsProp = property(get_connections, set_connections)
    def get_externalports(self): return self.externalports
    def set_externalports(self, externalports): self.externalports = externalports
    externalportsProp = property(get_externalports, set_externalports)
    def get_id(self): return self.id_
    def set_id(self, id_): self.id_ = id_
    id_Prop = property(get_id, set_id)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def export(self, outfile, level, namespace_='', name_='softwareassembly', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='softwareassembly')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='softwareassembly'):
        outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id_).encode(ExternalEncoding), input_name='id'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='softwareassembly'):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.componentfiles:
            self.componentfiles.export(outfile, level, namespace_, name_='componentfiles', )
        if self.partitioning:
            self.partitioning.export(outfile, level, namespace_, name_='partitioning', )
        if self.assemblycontroller:
            self.assemblycontroller.export(outfile, level, namespace_, name_='assemblycontroller', )
        if self.connections:
            self.connections.export(outfile, level, namespace_, name_='connections')
        if self.externalports:
            self.externalports.export(outfile, level, namespace_, name_='externalports')
    def hasContent_(self):
        if (
            self.description is not None or
            self.componentfiles is not None or
            self.partitioning is not None or
            self.assemblycontroller is not None or
            self.connections is not None or
            self.externalports is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='softwareassembly'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id_ is not None:
            showIndent(outfile, level)
            outfile.write('id_ = %s,\n' % (self.id_,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.componentfiles:
            showIndent(outfile, level)
            outfile.write('componentfiles=model_.componentfiles(\n')
            self.componentfiles.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.partitioning:
            showIndent(outfile, level)
            outfile.write('partitioning=model_.partitioning(\n')
            self.partitioning.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.assemblycontroller:
            showIndent(outfile, level)
            outfile.write('assemblycontroller=model_.assemblycontroller(\n')
            self.assemblycontroller.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.connections:
            showIndent(outfile, level)
            outfile.write('connections=model_.connections(\n')
            self.connections.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.externalports:
            showIndent(outfile, level)
            outfile.write('externalports=model_.externalports(\n')
            self.externalports.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('id'):
            self.id_ = attrs.get('id').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'description':
            description_ = ''
            for text__content_ in child_.childNodes:
                description_ += text__content_.nodeValue
            self.description = description_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'componentfiles':
            obj_ = componentfiles.factory()
            obj_.build(child_)
            self.set_componentfiles(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'partitioning':
            obj_ = partitioning.factory()
            obj_.build(child_)
            self.set_partitioning(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'assemblycontroller':
            obj_ = assemblycontroller.factory()
            obj_.build(child_)
            self.set_assemblycontroller(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'connections':
            obj_ = connections.factory()
            obj_.build(child_)
            self.set_connections(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'externalports':
            obj_ = externalports.factory()
            obj_.build(child_)
            self.set_externalports(obj_)
# end class softwareassembly


class componentfiles(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, componentfile=None):
        if componentfile is None:
            self.componentfile = []
        else:
            self.componentfile = componentfile
    def factory(*args_, **kwargs_):
        if componentfiles.subclass:
            return componentfiles.subclass(*args_, **kwargs_)
        else:
            return componentfiles(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_componentfile(self): return self.componentfile
    def set_componentfile(self, componentfile): self.componentfile = componentfile
    def add_componentfile(self, value): self.componentfile.append(value)
    def insert_componentfile(self, index, value): self.componentfile[index] = value
    componentfileProp = property(get_componentfile, set_componentfile)
    def export(self, outfile, level, namespace_='', name_='componentfiles', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='componentfiles')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='componentfiles'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='componentfiles'):
        for componentfile_ in self.componentfile:
            componentfile_.export(outfile, level, namespace_, name_='componentfile')
    def hasContent_(self):
        if (
            self.componentfile is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='componentfiles'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('componentfile=[\n')
        level += 1
        for componentfile in self.componentfile:
            showIndent(outfile, level)
            outfile.write('model_.componentfile(\n')
            componentfile.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'componentfile':
            obj_ = componentfile.factory()
            obj_.build(child_)
            self.componentfile.append(obj_)
# end class componentfiles


class componentfile(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, id_=None, localfile=None):
        self.type_ = type_
        self.id_ = id_
        self.localfile = localfile
    def factory(*args_, **kwargs_):
        if componentfile.subclass:
            return componentfile.subclass(*args_, **kwargs_)
        else:
            return componentfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_localfile(self): return self.localfile
    def set_localfile(self, localfile): self.localfile = localfile
    localfileProp = property(get_localfile, set_localfile)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    type_Prop = property(get_type, set_type)
    def get_id(self): return self.id_
    def set_id(self, id_): self.id_ = id_
    id_Prop = property(get_id, set_id)
    def export(self, outfile, level, namespace_='', name_='componentfile', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='componentfile')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='componentfile'):
        if self.type_ is not None:
            outfile.write(' type=%s' % (self.format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id_).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='componentfile'):
        if self.localfile:
            self.localfile.export(outfile, level, namespace_, name_='localfile', )
    def hasContent_(self):
        if (
            self.localfile is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='componentfile'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.id_ is not None:
            showIndent(outfile, level)
            outfile.write('id_ = %s,\n' % (self.id_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.localfile:
            showIndent(outfile, level)
            outfile.write('localfile=model_.localfile(\n')
            self.localfile.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('type'):
            self.type_ = attrs.get('type').value
        if attrs.get('id'):
            self.id_ = attrs.get('id').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'localfile':
            obj_ = localfile.factory()
            obj_.build(child_)
            self.set_localfile(obj_)
# end class componentfile


class localfile(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=''):
        self.name = name
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if localfile.subclass:
            return localfile.subclass(*args_, **kwargs_)
        else:
            return localfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='localfile', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='localfile')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='', name_='localfile'):
        outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='localfile'):
        if self.valueOf_.find('![CDATA')>-1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='localfile'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('name'):
            self.name = attrs.get('name').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class localfile


class partitioning(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, componentplacement=None, hostcollocation=None):
        if componentplacement is None:
            self.componentplacement = []
        else:
            self.componentplacement = componentplacement
        if hostcollocation is None:
            self.hostcollocation = []
        else:
            self.hostcollocation = hostcollocation
    def factory(*args_, **kwargs_):
        if partitioning.subclass:
            return partitioning.subclass(*args_, **kwargs_)
        else:
            return partitioning(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_componentplacement(self): return self.componentplacement
    def set_componentplacement(self, componentplacement): self.componentplacement = componentplacement
    def add_componentplacement(self, value): self.componentplacement.append(value)
    def insert_componentplacement(self, index, value): self.componentplacement[index] = value
    componentplacementProp = property(get_componentplacement, set_componentplacement)
    def get_hostcollocation(self): return self.hostcollocation
    def set_hostcollocation(self, hostcollocation): self.hostcollocation = hostcollocation
    def add_hostcollocation(self, value): self.hostcollocation.append(value)
    def insert_hostcollocation(self, index, value): self.hostcollocation[index] = value
    hostcollocationProp = property(get_hostcollocation, set_hostcollocation)
    def export(self, outfile, level, namespace_='', name_='partitioning', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='partitioning')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='partitioning'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='partitioning'):
        for componentplacement_ in self.componentplacement:
            componentplacement_.export(outfile, level, namespace_, name_='componentplacement')
        for hostcollocation_ in self.hostcollocation:
            hostcollocation_.export(outfile, level, namespace_, name_='hostcollocation')
    def hasContent_(self):
        if (
            self.componentplacement is not None or
            self.hostcollocation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='partitioning'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('componentplacement=[\n')
        level += 1
        for componentplacement in self.componentplacement:
            showIndent(outfile, level)
            outfile.write('model_.componentplacement(\n')
            componentplacement.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('hostcollocation=[\n')
        level += 1
        for hostcollocation in self.hostcollocation:
            showIndent(outfile, level)
            outfile.write('model_.hostcollocation(\n')
            hostcollocation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'componentplacement':
            obj_ = componentplacement.factory()
            obj_.build(child_)
            self.componentplacement.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'hostcollocation':
            obj_ = hostcollocation.factory()
            obj_.build(child_)
            self.hostcollocation.append(obj_)
# end class partitioning


class componentplacement(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, componentfileref=None, componentinstantiation=None):
        self.componentfileref = componentfileref
        if componentinstantiation is None:
            self.componentinstantiation = []
        else:
            self.componentinstantiation = componentinstantiation
    def factory(*args_, **kwargs_):
        if componentplacement.subclass:
            return componentplacement.subclass(*args_, **kwargs_)
        else:
            return componentplacement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_componentfileref(self): return self.componentfileref
    def set_componentfileref(self, componentfileref): self.componentfileref = componentfileref
    componentfilerefProp = property(get_componentfileref, set_componentfileref)
    def get_componentinstantiation(self): return self.componentinstantiation
    def set_componentinstantiation(self, componentinstantiation): self.componentinstantiation = componentinstantiation
    def add_componentinstantiation(self, value): self.componentinstantiation.append(value)
    def insert_componentinstantiation(self, index, value): self.componentinstantiation[index] = value
    componentinstantiationProp = property(get_componentinstantiation, set_componentinstantiation)
    def export(self, outfile, level, namespace_='', name_='componentplacement', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='componentplacement')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='componentplacement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='componentplacement'):
        if self.componentfileref:
            self.componentfileref.export(outfile, level, namespace_, name_='componentfileref', )
        for componentinstantiation_ in self.componentinstantiation:
            componentinstantiation_.export(outfile, level, namespace_, name_='componentinstantiation')
    def hasContent_(self):
        if (
            self.componentfileref is not None or
            self.componentinstantiation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='componentplacement'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.componentfileref:
            showIndent(outfile, level)
            outfile.write('componentfileref=model_.componentfileref(\n')
            self.componentfileref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('componentinstantiation=[\n')
        level += 1
        for componentinstantiation in self.componentinstantiation:
            showIndent(outfile, level)
            outfile.write('model_.componentinstantiation(\n')
            componentinstantiation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'componentfileref':
            obj_ = componentfileref.factory()
            obj_.build(child_)
            self.set_componentfileref(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'componentinstantiation':
            obj_ = componentinstantiation.factory()
            obj_.build(child_)
            self.componentinstantiation.append(obj_)
# end class componentplacement


class componentfileref(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, refid=None, valueOf_=''):
        self.refid = refid
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if componentfileref.subclass:
            return componentfileref.subclass(*args_, **kwargs_)
        else:
            return componentfileref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_refid(self): return self.refid
    def set_refid(self, refid): self.refid = refid
    refidProp = property(get_refid, set_refid)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='componentfileref', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='componentfileref')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='', name_='componentfileref'):
        outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='componentfileref'):
        if self.valueOf_.find('![CDATA')>-1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='componentfileref'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.refid is not None:
            showIndent(outfile, level)
            outfile.write('refid = %s,\n' % (self.refid,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('refid'):
            self.refid = attrs.get('refid').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class componentfileref


class componentinstantiation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id_=None, usagename=None, componentproperties=None, findcomponent=None):
        self.id_ = id_
        self.usagename = usagename
        self.componentproperties = componentproperties
        self.findcomponent = findcomponent
        self.startorder = None
    def factory(*args_, **kwargs_):
        if componentinstantiation.subclass:
            return componentinstantiation.subclass(*args_, **kwargs_)
        else:
            return componentinstantiation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_usagename(self): return self.usagename
    def set_usagename(self, usagename): self.usagename = usagename
    usagenameProp = property(get_usagename, set_usagename)
    def get_componentproperties(self): return self.componentproperties
    def set_componentproperties(self, componentproperties): self.componentproperties = componentproperties
    componentpropertiesProp = property(get_componentproperties, set_componentproperties)
    def get_findcomponent(self): return self.findcomponent
    def set_findcomponent(self, findcomponent): self.findcomponent = findcomponent
    findcomponentProp = property(get_findcomponent, set_findcomponent)
    def get_id(self): return self.id_
    def set_id(self, id_): self.id_ = id_
    id_Prop = property(get_id, set_id)
    def export(self, outfile, level, namespace_='', name_='componentinstantiation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='componentinstantiation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='componentinstantiation'):
        outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id_).encode(ExternalEncoding), input_name='id'), ))
        if self.get_startorder() is not None:
            outfile.write(' startorder=%s' % (self.format_string(quote_attrib(self.startorder).encode(ExternalEncoding), input_name='startorder'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='componentinstantiation'):
        if self.usagename is not None:
            showIndent(outfile, level)
            outfile.write('<%susagename>%s</%susagename>\n' % (namespace_, self.format_string(quote_xml(self.usagename).encode(ExternalEncoding), input_name='usagename'), namespace_))
        if self.componentproperties:
            self.componentproperties.export(outfile, level, namespace_, name_='componentproperties')
        if self.findcomponent:
            self.findcomponent.export(outfile, level, namespace_, name_='findcomponent')
    def hasContent_(self):
        if (
            self.usagename is not None or
            self.componentproperties is not None or
            self.findcomponent is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='componentinstantiation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id_ is not None:
            showIndent(outfile, level)
            outfile.write('id_ = %s,\n' % (self.id_,))
        if self.get_startorder() is not None:
            outfile.write('startorder = %s,\n' % (self.startorder,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('usagename=%s,\n' % quote_python(self.usagename).encode(ExternalEncoding))
        if self.componentproperties:
            showIndent(outfile, level)
            outfile.write('componentproperties=model_.componentproperties(\n')
            self.componentproperties.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.findcomponent:
            showIndent(outfile, level)
            outfile.write('findcomponent=model_.findcomponent(\n')
            self.findcomponent.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('id'):
            self.id_ = attrs.get('id').value
        if attrs.get('startorder') != None:
            self.startorder = attrs.get('startorder').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'usagename':
            usagename_ = ''
            for text__content_ in child_.childNodes:
                usagename_ += text__content_.nodeValue
            self.usagename = usagename_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'componentproperties':
            obj_ = componentproperties.factory()
            obj_.build(child_)
            self.set_componentproperties(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'findcomponent':
            obj_ = findcomponent.factory()
            obj_.build(child_)
            self.set_findcomponent(obj_)
    
    def get_startorder(self):
        try:
            return self.startorder
        except AttributeError:
            return None
    
    def set_startorder(self, startorder):
        self.startorder = startorder

# end class componentinstantiation


class componentproperties(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, simpleref=None, simplesequenceref=None, structref=None, structsequenceref=None):
        if simpleref is None:
            self.simpleref = []
        else:
            self.simpleref = simpleref
        if simplesequenceref is None:
            self.simplesequenceref = []
        else:
            self.simplesequenceref = simplesequenceref
        if structref is None:
            self.structref = []
        else:
            self.structref = structref
        if structsequenceref is None:
            self.structsequenceref = []
        else:
            self.structsequenceref = structsequenceref
    def factory(*args_, **kwargs_):
        if componentproperties.subclass:
            return componentproperties.subclass(*args_, **kwargs_)
        else:
            return componentproperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_simpleref(self): return self.simpleref
    def set_simpleref(self, simpleref): self.simpleref = simpleref
    def add_simpleref(self, value): self.simpleref.append(value)
    def insert_simpleref(self, index, value): self.simpleref[index] = value
    simplerefProp = property(get_simpleref, set_simpleref)
    def get_simplesequenceref(self): return self.simplesequenceref
    def set_simplesequenceref(self, simplesequenceref): self.simplesequenceref = simplesequenceref
    def add_simplesequenceref(self, value): self.simplesequenceref.append(value)
    def insert_simplesequenceref(self, index, value): self.simplesequenceref[index] = value
    simplesequencerefProp = property(get_simplesequenceref, set_simplesequenceref)
    def get_structref(self): return self.structref
    def set_structref(self, structref): self.structref = structref
    def add_structref(self, value): self.structref.append(value)
    def insert_structref(self, index, value): self.structref[index] = value
    structrefProp = property(get_structref, set_structref)
    def get_structsequenceref(self): return self.structsequenceref
    def set_structsequenceref(self, structsequenceref): self.structsequenceref = structsequenceref
    def add_structsequenceref(self, value): self.structsequenceref.append(value)
    def insert_structsequenceref(self, index, value): self.structsequenceref[index] = value
    structsequencerefProp = property(get_structsequenceref, set_structsequenceref)
    def export(self, outfile, level, namespace_='', name_='componentproperties', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='componentproperties')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='componentproperties'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='componentproperties'):
        for simpleref_ in self.simpleref:
            simpleref_.export(outfile, level, namespace_, name_='simpleref')
        for simplesequenceref_ in self.simplesequenceref:
            simplesequenceref_.export(outfile, level, namespace_, name_='simplesequenceref')
        for structref_ in self.structref:
            structref_.export(outfile, level, namespace_, name_='structref')
        for structsequenceref_ in self.structsequenceref:
            structsequenceref_.export(outfile, level, namespace_, name_='structsequenceref')
    def hasContent_(self):
        if (
            self.simpleref is not None or
            self.simplesequenceref is not None or
            self.structref is not None or
            self.structsequenceref is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='componentproperties'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('simpleref=[\n')
        level += 1
        for simpleref in self.simpleref:
            showIndent(outfile, level)
            outfile.write('model_.simpleref(\n')
            simpleref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('simplesequenceref=[\n')
        level += 1
        for simplesequenceref in self.simplesequenceref:
            showIndent(outfile, level)
            outfile.write('model_.simplesequenceref(\n')
            simplesequenceref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('structref=[\n')
        level += 1
        for structref in self.structref:
            showIndent(outfile, level)
            outfile.write('model_.structref(\n')
            structref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('structsequenceref=[\n')
        level += 1
        for structsequenceref in self.structsequenceref:
            showIndent(outfile, level)
            outfile.write('model_.structsequenceref(\n')
            structsequenceref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'simpleref':
            obj_ = simpleref.factory()
            obj_.build(child_)
            self.simpleref.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'simplesequenceref':
            obj_ = simplesequenceref.factory()
            obj_.build(child_)
            self.simplesequenceref.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'structref':
            obj_ = structref.factory()
            obj_.build(child_)
            self.structref.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'structsequenceref':
            obj_ = structsequenceref.factory()
            obj_.build(child_)
            self.structsequenceref.append(obj_)
# end class componentproperties


class findcomponent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, componentresourcefactoryref=None, namingservice=None):
        self.componentresourcefactoryref = componentresourcefactoryref
        self.namingservice = namingservice
    def factory(*args_, **kwargs_):
        if findcomponent.subclass:
            return findcomponent.subclass(*args_, **kwargs_)
        else:
            return findcomponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_componentresourcefactoryref(self): return self.componentresourcefactoryref
    def set_componentresourcefactoryref(self, componentresourcefactoryref): self.componentresourcefactoryref = componentresourcefactoryref
    componentresourcefactoryrefProp = property(get_componentresourcefactoryref, set_componentresourcefactoryref)
    def get_namingservice(self): return self.namingservice
    def set_namingservice(self, namingservice): self.namingservice = namingservice
    namingserviceProp = property(get_namingservice, set_namingservice)
    def export(self, outfile, level, namespace_='', name_='findcomponent', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='findcomponent')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='findcomponent'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='findcomponent'):
        if self.componentresourcefactoryref:
            self.componentresourcefactoryref.export(outfile, level, namespace_, name_='componentresourcefactoryref', )
        if self.namingservice:
            self.namingservice.export(outfile, level, namespace_, name_='namingservice', )
    def hasContent_(self):
        if (
            self.componentresourcefactoryref is not None or
            self.namingservice is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='findcomponent'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.componentresourcefactoryref:
            showIndent(outfile, level)
            outfile.write('componentresourcefactoryref=model_.componentresourcefactoryref(\n')
            self.componentresourcefactoryref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.namingservice:
            showIndent(outfile, level)
            outfile.write('namingservice=model_.namingservice(\n')
            self.namingservice.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'componentresourcefactoryref':
            obj_ = componentresourcefactoryref.factory()
            obj_.build(child_)
            self.set_componentresourcefactoryref(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'namingservice':
            obj_ = namingservice.factory()
            obj_.build(child_)
            self.set_namingservice(obj_)
# end class findcomponent


class componentresourcefactoryref(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, refid=None, resourcefactoryproperties=None):
        self.refid = refid
        self.resourcefactoryproperties = resourcefactoryproperties
    def factory(*args_, **kwargs_):
        if componentresourcefactoryref.subclass:
            return componentresourcefactoryref.subclass(*args_, **kwargs_)
        else:
            return componentresourcefactoryref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resourcefactoryproperties(self): return self.resourcefactoryproperties
    def set_resourcefactoryproperties(self, resourcefactoryproperties): self.resourcefactoryproperties = resourcefactoryproperties
    resourcefactorypropertiesProp = property(get_resourcefactoryproperties, set_resourcefactoryproperties)
    def get_refid(self): return self.refid
    def set_refid(self, refid): self.refid = refid
    refidProp = property(get_refid, set_refid)
    def export(self, outfile, level, namespace_='', name_='componentresourcefactoryref', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='componentresourcefactoryref')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='componentresourcefactoryref'):
        outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='componentresourcefactoryref'):
        if self.resourcefactoryproperties:
            self.resourcefactoryproperties.export(outfile, level, namespace_, name_='resourcefactoryproperties')
    def hasContent_(self):
        if (
            self.resourcefactoryproperties is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='componentresourcefactoryref'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.refid is not None:
            showIndent(outfile, level)
            outfile.write('refid = %s,\n' % (self.refid,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.resourcefactoryproperties:
            showIndent(outfile, level)
            outfile.write('resourcefactoryproperties=model_.resourcefactoryproperties(\n')
            self.resourcefactoryproperties.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('refid'):
            self.refid = attrs.get('refid').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'resourcefactoryproperties':
            obj_ = resourcefactoryproperties.factory()
            obj_.build(child_)
            self.set_resourcefactoryproperties(obj_)
# end class componentresourcefactoryref


class devicethatloadedthiscomponentref(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, refid=None, valueOf_=''):
        self.refid = refid
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if devicethatloadedthiscomponentref.subclass:
            return devicethatloadedthiscomponentref.subclass(*args_, **kwargs_)
        else:
            return devicethatloadedthiscomponentref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_refid(self): return self.refid
    def set_refid(self, refid): self.refid = refid
    refidProp = property(get_refid, set_refid)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='devicethatloadedthiscomponentref', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='devicethatloadedthiscomponentref')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='', name_='devicethatloadedthiscomponentref'):
        outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='devicethatloadedthiscomponentref'):
        if self.valueOf_.find('![CDATA')>-1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='devicethatloadedthiscomponentref'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.refid is not None:
            showIndent(outfile, level)
            outfile.write('refid = %s,\n' % (self.refid,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('refid'):
            self.refid = attrs.get('refid').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class devicethatloadedthiscomponentref


class deviceusedbythiscomponentref(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, usesrefid=None, refid=None, valueOf_=''):
        self.usesrefid = usesrefid
        self.refid = refid
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if deviceusedbythiscomponentref.subclass:
            return deviceusedbythiscomponentref.subclass(*args_, **kwargs_)
        else:
            return deviceusedbythiscomponentref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_usesrefid(self): return self.usesrefid
    def set_usesrefid(self, usesrefid): self.usesrefid = usesrefid
    usesrefidProp = property(get_usesrefid, set_usesrefid)
    def get_refid(self): return self.refid
    def set_refid(self, refid): self.refid = refid
    refidProp = property(get_refid, set_refid)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='deviceusedbythiscomponentref', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='deviceusedbythiscomponentref')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='', name_='deviceusedbythiscomponentref'):
        outfile.write(' usesrefid=%s' % (self.format_string(quote_attrib(self.usesrefid).encode(ExternalEncoding), input_name='usesrefid'), ))
        outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='deviceusedbythiscomponentref'):
        if self.valueOf_.find('![CDATA')>-1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='deviceusedbythiscomponentref'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.usesrefid is not None:
            showIndent(outfile, level)
            outfile.write('usesrefid = %s,\n' % (self.usesrefid,))
        if self.refid is not None:
            showIndent(outfile, level)
            outfile.write('refid = %s,\n' % (self.refid,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('usesrefid'):
            self.usesrefid = attrs.get('usesrefid').value
        if attrs.get('refid'):
            self.refid = attrs.get('refid').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class deviceusedbythiscomponentref


class resourcefactoryproperties(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, simpleref=None, simplesequenceref=None, structref=None, structsequenceref=None):
        if simpleref is None:
            self.simpleref = []
        else:
            self.simpleref = simpleref
        if simplesequenceref is None:
            self.simplesequenceref = []
        else:
            self.simplesequenceref = simplesequenceref
        if structref is None:
            self.structref = []
        else:
            self.structref = structref
        if structsequenceref is None:
            self.structsequenceref = []
        else:
            self.structsequenceref = structsequenceref
    def factory(*args_, **kwargs_):
        if resourcefactoryproperties.subclass:
            return resourcefactoryproperties.subclass(*args_, **kwargs_)
        else:
            return resourcefactoryproperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_simpleref(self): return self.simpleref
    def set_simpleref(self, simpleref): self.simpleref = simpleref
    def add_simpleref(self, value): self.simpleref.append(value)
    def insert_simpleref(self, index, value): self.simpleref[index] = value
    simplerefProp = property(get_simpleref, set_simpleref)
    def get_simplesequenceref(self): return self.simplesequenceref
    def set_simplesequenceref(self, simplesequenceref): self.simplesequenceref = simplesequenceref
    def add_simplesequenceref(self, value): self.simplesequenceref.append(value)
    def insert_simplesequenceref(self, index, value): self.simplesequenceref[index] = value
    simplesequencerefProp = property(get_simplesequenceref, set_simplesequenceref)
    def get_structref(self): return self.structref
    def set_structref(self, structref): self.structref = structref
    def add_structref(self, value): self.structref.append(value)
    def insert_structref(self, index, value): self.structref[index] = value
    structrefProp = property(get_structref, set_structref)
    def get_structsequenceref(self): return self.structsequenceref
    def set_structsequenceref(self, structsequenceref): self.structsequenceref = structsequenceref
    def add_structsequenceref(self, value): self.structsequenceref.append(value)
    def insert_structsequenceref(self, index, value): self.structsequenceref[index] = value
    structsequencerefProp = property(get_structsequenceref, set_structsequenceref)
    def export(self, outfile, level, namespace_='', name_='resourcefactoryproperties', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='resourcefactoryproperties')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='resourcefactoryproperties'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='resourcefactoryproperties'):
        for simpleref_ in self.simpleref:
            simpleref_.export(outfile, level, namespace_, name_='simpleref')
        for simplesequenceref_ in self.simplesequenceref:
            simplesequenceref_.export(outfile, level, namespace_, name_='simplesequenceref')
        for structref_ in self.structref:
            structref_.export(outfile, level, namespace_, name_='structref')
        for structsequenceref_ in self.structsequenceref:
            structsequenceref_.export(outfile, level, namespace_, name_='structsequenceref')
    def hasContent_(self):
        if (
            self.simpleref is not None or
            self.simplesequenceref is not None or
            self.structref is not None or
            self.structsequenceref is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='resourcefactoryproperties'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('simpleref=[\n')
        level += 1
        for simpleref in self.simpleref:
            showIndent(outfile, level)
            outfile.write('model_.simpleref(\n')
            simpleref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('simplesequenceref=[\n')
        level += 1
        for simplesequenceref in self.simplesequenceref:
            showIndent(outfile, level)
            outfile.write('model_.simplesequenceref(\n')
            simplesequenceref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('structref=[\n')
        level += 1
        for structref in self.structref:
            showIndent(outfile, level)
            outfile.write('model_.structref(\n')
            structref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('structsequenceref=[\n')
        level += 1
        for structsequenceref in self.structsequenceref:
            showIndent(outfile, level)
            outfile.write('model_.structsequenceref(\n')
            structsequenceref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'simpleref':
            obj_ = simpleref.factory()
            obj_.build(child_)
            self.simpleref.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'simplesequenceref':
            obj_ = simplesequenceref.factory()
            obj_.build(child_)
            self.simplesequenceref.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'structref':
            obj_ = structref.factory()
            obj_.build(child_)
            self.structref.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'structsequenceref':
            obj_ = structsequenceref.factory()
            obj_.build(child_)
            self.structsequenceref.append(obj_)
# end class resourcefactoryproperties


class simpleref(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, refid=None, value=None, valueOf_=''):
        self.refid = refid
        self.value = value
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if simpleref.subclass:
            return simpleref.subclass(*args_, **kwargs_)
        else:
            return simpleref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_refid(self): return self.refid
    def set_refid(self, refid): self.refid = refid
    refidProp = property(get_refid, set_refid)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    valueProp = property(get_value, set_value)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='simpleref', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='simpleref')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='', name_='simpleref'):
        outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
        outfile.write(' value=%s' % (self.format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='simpleref'):
        if self.valueOf_.find('![CDATA')>-1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='simpleref'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.refid is not None:
            showIndent(outfile, level)
            outfile.write('refid = %s,\n' % (self.refid,))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value = %s,\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('refid'):
            self.refid = attrs.get('refid').value
        if attrs.get('value'):
            self.value = attrs.get('value').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class simpleref


class simplesequenceref(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, refid=None, values=None):
        self.refid = refid
        self.values = values
    def factory(*args_, **kwargs_):
        if simplesequenceref.subclass:
            return simplesequenceref.subclass(*args_, **kwargs_)
        else:
            return simplesequenceref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_values(self): return self.values
    def set_values(self, values): self.values = values
    valuesProp = property(get_values, set_values)
    def get_refid(self): return self.refid
    def set_refid(self, refid): self.refid = refid
    refidProp = property(get_refid, set_refid)
    def export(self, outfile, level, namespace_='', name_='simplesequenceref', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='simplesequenceref')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='simplesequenceref'):
        outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='simplesequenceref'):
        if self.values:
            self.values.export(outfile, level, namespace_, name_='values', )
    def hasContent_(self):
        if (
            self.values is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='simplesequenceref'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.refid is not None:
            showIndent(outfile, level)
            outfile.write('refid = %s,\n' % (self.refid,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.values:
            showIndent(outfile, level)
            outfile.write('values=model_.values(\n')
            self.values.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('refid'):
            self.refid = attrs.get('refid').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'values':
            obj_ = values.factory()
            obj_.build(child_)
            self.set_values(obj_)
# end class simplesequenceref


class structref(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, refid=None, simpleref=None):
        self.refid = refid
        if simpleref is None:
            self.simpleref = []
        else:
            self.simpleref = simpleref
    def factory(*args_, **kwargs_):
        if structref.subclass:
            return structref.subclass(*args_, **kwargs_)
        else:
            return structref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_simpleref(self): return self.simpleref
    def set_simpleref(self, simpleref): self.simpleref = simpleref
    def add_simpleref(self, value): self.simpleref.append(value)
    def insert_simpleref(self, index, value): self.simpleref[index] = value
    simplerefProp = property(get_simpleref, set_simpleref)
    def get_refid(self): return self.refid
    def set_refid(self, refid): self.refid = refid
    refidProp = property(get_refid, set_refid)
    def export(self, outfile, level, namespace_='', name_='structref', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='structref')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='structref'):
        outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='structref'):
        for simpleref_ in self.simpleref:
            simpleref_.export(outfile, level, namespace_, name_='simpleref')
    def hasContent_(self):
        if (
            self.simpleref is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='structref'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.refid is not None:
            showIndent(outfile, level)
            outfile.write('refid = %s,\n' % (self.refid,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('simpleref=[\n')
        level += 1
        for simpleref in self.simpleref:
            showIndent(outfile, level)
            outfile.write('model_.simpleref(\n')
            simpleref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('refid'):
            self.refid = attrs.get('refid').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'simpleref':
            obj_ = simpleref.factory()
            obj_.build(child_)
            self.simpleref.append(obj_)
# end class structref


class structsequenceref(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, refid=None, structvalue=None):
        self.refid = refid
        if structvalue is None:
            self.structvalue = []
        else:
            self.structvalue = structvalue
    def factory(*args_, **kwargs_):
        if structsequenceref.subclass:
            return structsequenceref.subclass(*args_, **kwargs_)
        else:
            return structsequenceref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_structvalue(self): return self.structvalue
    def set_structvalue(self, structvalue): self.structvalue = structvalue
    def add_structvalue(self, value): self.structvalue.append(value)
    def insert_structvalue(self, index, value): self.structvalue[index] = value
    structvalueProp = property(get_structvalue, set_structvalue)
    def get_refid(self): return self.refid
    def set_refid(self, refid): self.refid = refid
    refidProp = property(get_refid, set_refid)
    def export(self, outfile, level, namespace_='', name_='structsequenceref', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='structsequenceref')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='structsequenceref'):
        outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='structsequenceref'):
        for structvalue_ in self.structvalue:
            structvalue_.export(outfile, level, namespace_, name_='structvalue')
    def hasContent_(self):
        if (
            self.structvalue is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='structsequenceref'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.refid is not None:
            showIndent(outfile, level)
            outfile.write('refid = %s,\n' % (self.refid,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('structvalue=[\n')
        level += 1
        for structvalue in self.structvalue:
            showIndent(outfile, level)
            outfile.write('model_.structvalue(\n')
            structvalue.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('refid'):
            self.refid = attrs.get('refid').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'structvalue':
            obj_ = structvalue.factory()
            obj_.build(child_)
            self.structvalue.append(obj_)
# end class structsequenceref


class structvalue(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, simpleref=None):
        if simpleref is None:
            self.simpleref = []
        else:
            self.simpleref = simpleref
    def factory(*args_, **kwargs_):
        if structvalue.subclass:
            return structvalue.subclass(*args_, **kwargs_)
        else:
            return structvalue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_simpleref(self): return self.simpleref
    def set_simpleref(self, simpleref): self.simpleref = simpleref
    def add_simpleref(self, value): self.simpleref.append(value)
    def insert_simpleref(self, index, value): self.simpleref[index] = value
    simplerefProp = property(get_simpleref, set_simpleref)
    def export(self, outfile, level, namespace_='', name_='structvalue', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='structvalue')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='structvalue'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='structvalue'):
        for simpleref_ in self.simpleref:
            simpleref_.export(outfile, level, namespace_, name_='simpleref')
    def hasContent_(self):
        if (
            self.simpleref is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='structvalue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('simpleref=[\n')
        level += 1
        for simpleref in self.simpleref:
            showIndent(outfile, level)
            outfile.write('model_.simpleref(\n')
            simpleref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'simpleref':
            obj_ = simpleref.factory()
            obj_.build(child_)
            self.simpleref.append(obj_)
# end class structvalue


class values(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None):
        if value is None:
            self.value = []
        else:
            self.value = value
    def factory(*args_, **kwargs_):
        if values.subclass:
            return values.subclass(*args_, **kwargs_)
        else:
            return values(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    valueProp = property(get_value, set_value)
    def export(self, outfile, level, namespace_='', name_='values', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='values')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='values'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='values'):
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('<%svalue>%s</%svalue>\n' % (namespace_, self.format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_))
    def hasContent_(self):
        if (
            self.value is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='values'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'value':
            value_ = ''
            for text__content_ in child_.childNodes:
                value_ += text__content_.nodeValue
            self.value.append(value_)
# end class values


class componentinstantiationref(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, refid=None, valueOf_=''):
        self.refid = refid
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if componentinstantiationref.subclass:
            return componentinstantiationref.subclass(*args_, **kwargs_)
        else:
            return componentinstantiationref(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_refid(self): return self.refid
    def set_refid(self, refid): self.refid = refid
    refidProp = property(get_refid, set_refid)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='componentinstantiationref', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='componentinstantiationref')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='', name_='componentinstantiationref'):
        outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='componentinstantiationref'):
        if self.valueOf_.find('![CDATA')>-1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='componentinstantiationref'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.refid is not None:
            showIndent(outfile, level)
            outfile.write('refid = %s,\n' % (self.refid,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('refid'):
            self.refid = attrs.get('refid').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class componentinstantiationref


class findby(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, namingservice=None, stringifiedobjectref=None, domainfinder=None):
        self.namingservice = namingservice
        self.stringifiedobjectref = stringifiedobjectref
        self.domainfinder = domainfinder
    def factory(*args_, **kwargs_):
        if findby.subclass:
            return findby.subclass(*args_, **kwargs_)
        else:
            return findby(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_namingservice(self): return self.namingservice
    def set_namingservice(self, namingservice): self.namingservice = namingservice
    namingserviceProp = property(get_namingservice, set_namingservice)
    def get_stringifiedobjectref(self): return self.stringifiedobjectref
    def set_stringifiedobjectref(self, stringifiedobjectref): self.stringifiedobjectref = stringifiedobjectref
    stringifiedobjectrefProp = property(get_stringifiedobjectref, set_stringifiedobjectref)
    def get_domainfinder(self): return self.domainfinder
    def set_domainfinder(self, domainfinder): self.domainfinder = domainfinder
    domainfinderProp = property(get_domainfinder, set_domainfinder)
    def export(self, outfile, level, namespace_='', name_='findby', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='findby')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='findby'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='findby'):
        if self.namingservice:
            self.namingservice.export(outfile, level, namespace_, name_='namingservice', )
        if self.stringifiedobjectref is not None:
            showIndent(outfile, level)
            outfile.write('<%sstringifiedobjectref>%s</%sstringifiedobjectref>\n' % (namespace_, self.format_string(quote_xml(self.stringifiedobjectref).encode(ExternalEncoding), input_name='stringifiedobjectref'), namespace_))
        if self.domainfinder:
            self.domainfinder.export(outfile, level, namespace_, name_='domainfinder', )
    def hasContent_(self):
        if (
            self.namingservice is not None or
            self.stringifiedobjectref is not None or
            self.domainfinder is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='findby'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.namingservice:
            showIndent(outfile, level)
            outfile.write('namingservice=model_.namingservice(\n')
            self.namingservice.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('stringifiedobjectref=%s,\n' % quote_python(self.stringifiedobjectref).encode(ExternalEncoding))
        if self.domainfinder:
            showIndent(outfile, level)
            outfile.write('domainfinder=model_.domainfinder(\n')
            self.domainfinder.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'namingservice':
            obj_ = namingservice.factory()
            obj_.build(child_)
            self.set_namingservice(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'stringifiedobjectref':
            stringifiedobjectref_ = ''
            for text__content_ in child_.childNodes:
                stringifiedobjectref_ += text__content_.nodeValue
            self.stringifiedobjectref = stringifiedobjectref_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'domainfinder':
            obj_ = domainfinder.factory()
            obj_.build(child_)
            self.set_domainfinder(obj_)
# end class findby


class namingservice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=''):
        self.name = name
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if namingservice.subclass:
            return namingservice.subclass(*args_, **kwargs_)
        else:
            return namingservice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='namingservice', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='namingservice')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='', name_='namingservice'):
        outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='namingservice'):
        if self.valueOf_.find('![CDATA')>-1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='namingservice'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('name'):
            self.name = attrs.get('name').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class namingservice


class domainfinder(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, name=None, valueOf_=''):
        self.type_ = type_
        self.name = name
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if domainfinder.subclass:
            return domainfinder.subclass(*args_, **kwargs_)
        else:
            return domainfinder(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    type_Prop = property(get_type, set_type)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='domainfinder', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='domainfinder')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='', name_='domainfinder'):
        outfile.write(' type=%s' % (self.format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='domainfinder'):
        if self.valueOf_.find('![CDATA')>-1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='domainfinder'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('type'):
            self.type_ = attrs.get('type').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class domainfinder


class hostcollocation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id_=None, name=None, componentplacement=None):
        self.id_ = id_
        self.name = name
        if componentplacement == None:
            self.componentplacement = []
        else:
            self.componentplacement = componentplacement
    def factory(*args_, **kwargs_):
        if hostcollocation.subclass:
            return hostcollocation.subclass(*args_, **kwargs_)
        else:
            return hostcollocation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_componentplacement(self): return self.componentplacement
    def set_componentplacement(self, componentplacement): self.componentplacement = componentplacement
    componentplacementProp = property(get_componentplacement, set_componentplacement)
    def get_id(self): return self.id_
    def set_id(self, id_): self.id_ = id_
    id_Prop = property(get_id, set_id)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def export(self, outfile, level, namespace_='', name_='hostcollocation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='hostcollocation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='hostcollocation'):
        if self.id_ is not None:
            outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id_).encode(ExternalEncoding), input_name='id'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='hostcollocation'):
        if self.componentplacement:
            self.componentplacement.export(outfile, level, namespace_, name_='componentplacement', )
    def hasContent_(self):
        if (
            self.componentplacement is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='hostcollocation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id_ is not None:
            showIndent(outfile, level)
            outfile.write('id_ = %s,\n' % (self.id_,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.componentplacement:
            showIndent(outfile, level)
            outfile.write('componentplacement=model_.componentplacement(\n')
            self.componentplacement.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('id'):
            self.id_ = attrs.get('id').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'componentplacement':
            obj_ = componentplacement.factory()
            obj_.build(child_)
            self.componentplacement.append(obj_)
# end class hostcollocation


class assemblycontroller(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, componentinstantiationref=None):
        self.componentinstantiationref = componentinstantiationref
    def factory(*args_, **kwargs_):
        if assemblycontroller.subclass:
            return assemblycontroller.subclass(*args_, **kwargs_)
        else:
            return assemblycontroller(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_componentinstantiationref(self): return self.componentinstantiationref
    def set_componentinstantiationref(self, componentinstantiationref): self.componentinstantiationref = componentinstantiationref
    componentinstantiationrefProp = property(get_componentinstantiationref, set_componentinstantiationref)
    def export(self, outfile, level, namespace_='', name_='assemblycontroller', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='assemblycontroller')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='assemblycontroller'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='assemblycontroller'):
        if self.componentinstantiationref:
            self.componentinstantiationref.export(outfile, level, namespace_, name_='componentinstantiationref', )
    def hasContent_(self):
        if (
            self.componentinstantiationref is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='assemblycontroller'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.componentinstantiationref:
            showIndent(outfile, level)
            outfile.write('componentinstantiationref=model_.componentinstantiationref(\n')
            self.componentinstantiationref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'componentinstantiationref':
            obj_ = componentinstantiationref.factory()
            obj_.build(child_)
            self.set_componentinstantiationref(obj_)
# end class assemblycontroller


class connections(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, connectinterface=None):
        if connectinterface is None:
            self.connectinterface = []
        else:
            self.connectinterface = connectinterface
    def factory(*args_, **kwargs_):
        if connections.subclass:
            return connections.subclass(*args_, **kwargs_)
        else:
            return connections(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_connectinterface(self): return self.connectinterface
    def set_connectinterface(self, connectinterface): self.connectinterface = connectinterface
    def add_connectinterface(self, value): self.connectinterface.append(value)
    def insert_connectinterface(self, index, value): self.connectinterface[index] = value
    connectinterfaceProp = property(get_connectinterface, set_connectinterface)
    def export(self, outfile, level, namespace_='', name_='connections', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='connections')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='connections'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='connections'):
        for connectinterface_ in self.connectinterface:
            connectinterface_.export(outfile, level, namespace_, name_='connectinterface')
    def hasContent_(self):
        if (
            self.connectinterface is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='connections'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('connectinterface=[\n')
        level += 1
        for connectinterface in self.connectinterface:
            showIndent(outfile, level)
            outfile.write('model_.connectinterface(\n')
            connectinterface.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'connectinterface':
            obj_ = connectinterface.factory()
            obj_.build(child_)
            self.connectinterface.append(obj_)
# end class connections


class connectinterface(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id_=None, usesport=None, providesport=None, componentsupportedinterface=None, findby=None):
        self.id_ = id_
        self.usesport = usesport
        self.providesport = providesport
        self.componentsupportedinterface = componentsupportedinterface
        self.findby = findby
    def factory(*args_, **kwargs_):
        if connectinterface.subclass:
            return connectinterface.subclass(*args_, **kwargs_)
        else:
            return connectinterface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_usesport(self): return self.usesport
    def set_usesport(self, usesport): self.usesport = usesport
    usesportProp = property(get_usesport, set_usesport)
    def get_providesport(self): return self.providesport
    def set_providesport(self, providesport): self.providesport = providesport
    providesportProp = property(get_providesport, set_providesport)
    def get_componentsupportedinterface(self): return self.componentsupportedinterface
    def set_componentsupportedinterface(self, componentsupportedinterface): self.componentsupportedinterface = componentsupportedinterface
    componentsupportedinterfaceProp = property(get_componentsupportedinterface, set_componentsupportedinterface)
    def get_findby(self): return self.findby
    def set_findby(self, findby): self.findby = findby
    findbyProp = property(get_findby, set_findby)
    def get_id(self): return self.id_
    def set_id(self, id_): self.id_ = id_
    id_Prop = property(get_id, set_id)
    def export(self, outfile, level, namespace_='', name_='connectinterface', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='connectinterface')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='connectinterface'):
        if self.id_ is not None:
            outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id_).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='connectinterface'):
        if self.usesport:
            self.usesport.export(outfile, level, namespace_, name_='usesport', )
        if self.providesport:
            self.providesport.export(outfile, level, namespace_, name_='providesport', )
        if self.componentsupportedinterface:
            self.componentsupportedinterface.export(outfile, level, namespace_, name_='componentsupportedinterface', )
        if self.findby:
            self.findby.export(outfile, level, namespace_, name_='findby', )
    def hasContent_(self):
        if (
            self.usesport is not None or
            self.providesport is not None or
            self.componentsupportedinterface is not None or
            self.findby is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='connectinterface'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id_ is not None:
            showIndent(outfile, level)
            outfile.write('id_ = %s,\n' % (self.id_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.usesport:
            showIndent(outfile, level)
            outfile.write('usesport=model_.usesport(\n')
            self.usesport.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.providesport:
            showIndent(outfile, level)
            outfile.write('providesport=model_.providesport(\n')
            self.providesport.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.componentsupportedinterface:
            showIndent(outfile, level)
            outfile.write('componentsupportedinterface=model_.componentsupportedinterface(\n')
            self.componentsupportedinterface.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.findby:
            showIndent(outfile, level)
            outfile.write('findby=model_.findby(\n')
            self.findby.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('id'):
            self.id_ = attrs.get('id').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'usesport':
            obj_ = usesport.factory()
            obj_.build(child_)
            self.set_usesport(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'providesport':
            obj_ = providesport.factory()
            obj_.build(child_)
            self.set_providesport(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'componentsupportedinterface':
            obj_ = componentsupportedinterface.factory()
            obj_.build(child_)
            self.set_componentsupportedinterface(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'findby':
            obj_ = findby.factory()
            obj_.build(child_)
            self.set_findby(obj_)
# end class connectinterface


class usesport(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, usesidentifier=None, componentinstantiationref=None, devicethatloadedthiscomponentref=None, deviceusedbythiscomponentref=None, findby=None):
        self.usesidentifier = usesidentifier
        self.componentinstantiationref = componentinstantiationref
        self.devicethatloadedthiscomponentref = devicethatloadedthiscomponentref
        self.deviceusedbythiscomponentref = deviceusedbythiscomponentref
        self.findby = findby
    def factory(*args_, **kwargs_):
        if usesport.subclass:
            return usesport.subclass(*args_, **kwargs_)
        else:
            return usesport(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_usesidentifier(self): return self.usesidentifier
    def set_usesidentifier(self, usesidentifier): self.usesidentifier = usesidentifier
    usesidentifierProp = property(get_usesidentifier, set_usesidentifier)
    def get_componentinstantiationref(self): return self.componentinstantiationref
    def set_componentinstantiationref(self, componentinstantiationref): self.componentinstantiationref = componentinstantiationref
    componentinstantiationrefProp = property(get_componentinstantiationref, set_componentinstantiationref)
    def get_devicethatloadedthiscomponentref(self): return self.devicethatloadedthiscomponentref
    def set_devicethatloadedthiscomponentref(self, devicethatloadedthiscomponentref): self.devicethatloadedthiscomponentref = devicethatloadedthiscomponentref
    devicethatloadedthiscomponentrefProp = property(get_devicethatloadedthiscomponentref, set_devicethatloadedthiscomponentref)
    def get_deviceusedbythiscomponentref(self): return self.deviceusedbythiscomponentref
    def set_deviceusedbythiscomponentref(self, deviceusedbythiscomponentref): self.deviceusedbythiscomponentref = deviceusedbythiscomponentref
    deviceusedbythiscomponentrefProp = property(get_deviceusedbythiscomponentref, set_deviceusedbythiscomponentref)
    def get_findby(self): return self.findby
    def set_findby(self, findby): self.findby = findby
    findbyProp = property(get_findby, set_findby)
    def export(self, outfile, level, namespace_='', name_='usesport', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='usesport')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='usesport'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='usesport'):
        if self.usesidentifier is not None:
            showIndent(outfile, level)
            outfile.write('<%susesidentifier>%s</%susesidentifier>\n' % (namespace_, self.format_string(quote_xml(self.usesidentifier).encode(ExternalEncoding), input_name='usesidentifier'), namespace_))
        if self.componentinstantiationref:
            self.componentinstantiationref.export(outfile, level, namespace_, name_='componentinstantiationref', )
        if self.devicethatloadedthiscomponentref:
            self.devicethatloadedthiscomponentref.export(outfile, level, namespace_, name_='devicethatloadedthiscomponentref', )
        if self.deviceusedbythiscomponentref:
            self.deviceusedbythiscomponentref.export(outfile, level, namespace_, name_='deviceusedbythiscomponentref', )
        if self.findby:
            self.findby.export(outfile, level, namespace_, name_='findby', )
    def hasContent_(self):
        if (
            self.usesidentifier is not None or
            self.componentinstantiationref is not None or
            self.devicethatloadedthiscomponentref is not None or
            self.deviceusedbythiscomponentref is not None or
            self.findby is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='usesport'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('usesidentifier=%s,\n' % quote_python(self.usesidentifier).encode(ExternalEncoding))
        if self.componentinstantiationref:
            showIndent(outfile, level)
            outfile.write('componentinstantiationref=model_.componentinstantiationref(\n')
            self.componentinstantiationref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.devicethatloadedthiscomponentref:
            showIndent(outfile, level)
            outfile.write('devicethatloadedthiscomponentref=model_.devicethatloadedthiscomponentref(\n')
            self.devicethatloadedthiscomponentref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.deviceusedbythiscomponentref:
            showIndent(outfile, level)
            outfile.write('deviceusedbythiscomponentref=model_.deviceusedbythiscomponentref(\n')
            self.deviceusedbythiscomponentref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.findby:
            showIndent(outfile, level)
            outfile.write('findby=model_.findby(\n')
            self.findby.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'usesidentifier':
            usesidentifier_ = ''
            for text__content_ in child_.childNodes:
                usesidentifier_ += text__content_.nodeValue
            self.usesidentifier = usesidentifier_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'componentinstantiationref':
            obj_ = componentinstantiationref.factory()
            obj_.build(child_)
            self.set_componentinstantiationref(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'devicethatloadedthiscomponentref':
            obj_ = devicethatloadedthiscomponentref.factory()
            obj_.build(child_)
            self.set_devicethatloadedthiscomponentref(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'deviceusedbythiscomponentref':
            obj_ = deviceusedbythiscomponentref.factory()
            obj_.build(child_)
            self.set_deviceusedbythiscomponentref(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'findby':
            obj_ = findby.factory()
            obj_.build(child_)
            self.set_findby(obj_)
# end class usesport


class providesport(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, providesidentifier=None, componentinstantiationref=None, devicethatloadedthiscomponentref=None, deviceusedbythiscomponentref=None, findby=None):
        self.providesidentifier = providesidentifier
        self.componentinstantiationref = componentinstantiationref
        self.devicethatloadedthiscomponentref = devicethatloadedthiscomponentref
        self.deviceusedbythiscomponentref = deviceusedbythiscomponentref
        self.findby = findby
    def factory(*args_, **kwargs_):
        if providesport.subclass:
            return providesport.subclass(*args_, **kwargs_)
        else:
            return providesport(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_providesidentifier(self): return self.providesidentifier
    def set_providesidentifier(self, providesidentifier): self.providesidentifier = providesidentifier
    providesidentifierProp = property(get_providesidentifier, set_providesidentifier)
    def get_componentinstantiationref(self): return self.componentinstantiationref
    def set_componentinstantiationref(self, componentinstantiationref): self.componentinstantiationref = componentinstantiationref
    componentinstantiationrefProp = property(get_componentinstantiationref, set_componentinstantiationref)
    def get_devicethatloadedthiscomponentref(self): return self.devicethatloadedthiscomponentref
    def set_devicethatloadedthiscomponentref(self, devicethatloadedthiscomponentref): self.devicethatloadedthiscomponentref = devicethatloadedthiscomponentref
    devicethatloadedthiscomponentrefProp = property(get_devicethatloadedthiscomponentref, set_devicethatloadedthiscomponentref)
    def get_deviceusedbythiscomponentref(self): return self.deviceusedbythiscomponentref
    def set_deviceusedbythiscomponentref(self, deviceusedbythiscomponentref): self.deviceusedbythiscomponentref = deviceusedbythiscomponentref
    deviceusedbythiscomponentrefProp = property(get_deviceusedbythiscomponentref, set_deviceusedbythiscomponentref)
    def get_findby(self): return self.findby
    def set_findby(self, findby): self.findby = findby
    findbyProp = property(get_findby, set_findby)
    def export(self, outfile, level, namespace_='', name_='providesport', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='providesport')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='providesport'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='providesport'):
        if self.providesidentifier is not None:
            showIndent(outfile, level)
            outfile.write('<%sprovidesidentifier>%s</%sprovidesidentifier>\n' % (namespace_, self.format_string(quote_xml(self.providesidentifier).encode(ExternalEncoding), input_name='providesidentifier'), namespace_))
        if self.componentinstantiationref:
            self.componentinstantiationref.export(outfile, level, namespace_, name_='componentinstantiationref', )
        if self.devicethatloadedthiscomponentref:
            self.devicethatloadedthiscomponentref.export(outfile, level, namespace_, name_='devicethatloadedthiscomponentref', )
        if self.deviceusedbythiscomponentref:
            self.deviceusedbythiscomponentref.export(outfile, level, namespace_, name_='deviceusedbythiscomponentref', )
        if self.findby:
            self.findby.export(outfile, level, namespace_, name_='findby', )
    def hasContent_(self):
        if (
            self.providesidentifier is not None or
            self.componentinstantiationref is not None or
            self.devicethatloadedthiscomponentref is not None or
            self.deviceusedbythiscomponentref is not None or
            self.findby is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='providesport'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('providesidentifier=%s,\n' % quote_python(self.providesidentifier).encode(ExternalEncoding))
        if self.componentinstantiationref:
            showIndent(outfile, level)
            outfile.write('componentinstantiationref=model_.componentinstantiationref(\n')
            self.componentinstantiationref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.devicethatloadedthiscomponentref:
            showIndent(outfile, level)
            outfile.write('devicethatloadedthiscomponentref=model_.devicethatloadedthiscomponentref(\n')
            self.devicethatloadedthiscomponentref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.deviceusedbythiscomponentref:
            showIndent(outfile, level)
            outfile.write('deviceusedbythiscomponentref=model_.deviceusedbythiscomponentref(\n')
            self.deviceusedbythiscomponentref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.findby:
            showIndent(outfile, level)
            outfile.write('findby=model_.findby(\n')
            self.findby.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'providesidentifier':
            providesidentifier_ = ''
            for text__content_ in child_.childNodes:
                providesidentifier_ += text__content_.nodeValue
            self.providesidentifier = providesidentifier_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'componentinstantiationref':
            obj_ = componentinstantiationref.factory()
            obj_.build(child_)
            self.set_componentinstantiationref(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'devicethatloadedthiscomponentref':
            obj_ = devicethatloadedthiscomponentref.factory()
            obj_.build(child_)
            self.set_devicethatloadedthiscomponentref(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'deviceusedbythiscomponentref':
            obj_ = deviceusedbythiscomponentref.factory()
            obj_.build(child_)
            self.set_deviceusedbythiscomponentref(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'findby':
            obj_ = findby.factory()
            obj_.build(child_)
            self.set_findby(obj_)
# end class providesport


class componentsupportedinterface(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, supportedidentifier=None, componentinstantiationref=None, findby=None):
        self.supportedidentifier = supportedidentifier
        self.componentinstantiationref = componentinstantiationref
        self.findby = findby
    def factory(*args_, **kwargs_):
        if componentsupportedinterface.subclass:
            return componentsupportedinterface.subclass(*args_, **kwargs_)
        else:
            return componentsupportedinterface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_supportedidentifier(self): return self.supportedidentifier
    def set_supportedidentifier(self, supportedidentifier): self.supportedidentifier = supportedidentifier
    supportedidentifierProp = property(get_supportedidentifier, set_supportedidentifier)
    def get_componentinstantiationref(self): return self.componentinstantiationref
    def set_componentinstantiationref(self, componentinstantiationref): self.componentinstantiationref = componentinstantiationref
    componentinstantiationrefProp = property(get_componentinstantiationref, set_componentinstantiationref)
    def get_findby(self): return self.findby
    def set_findby(self, findby): self.findby = findby
    findbyProp = property(get_findby, set_findby)
    def export(self, outfile, level, namespace_='', name_='componentsupportedinterface', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='componentsupportedinterface')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='componentsupportedinterface'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='componentsupportedinterface'):
        if self.supportedidentifier is not None:
            showIndent(outfile, level)
            outfile.write('<%ssupportedidentifier>%s</%ssupportedidentifier>\n' % (namespace_, self.format_string(quote_xml(self.supportedidentifier).encode(ExternalEncoding), input_name='supportedidentifier'), namespace_))
        if self.componentinstantiationref:
            self.componentinstantiationref.export(outfile, level, namespace_, name_='componentinstantiationref', )
        if self.findby:
            self.findby.export(outfile, level, namespace_, name_='findby', )
    def hasContent_(self):
        if (
            self.supportedidentifier is not None or
            self.componentinstantiationref is not None or
            self.findby is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='componentsupportedinterface'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('supportedidentifier=%s,\n' % quote_python(self.supportedidentifier).encode(ExternalEncoding))
        if self.componentinstantiationref:
            showIndent(outfile, level)
            outfile.write('componentinstantiationref=model_.componentinstantiationref(\n')
            self.componentinstantiationref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.findby:
            showIndent(outfile, level)
            outfile.write('findby=model_.findby(\n')
            self.findby.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'supportedidentifier':
            supportedidentifier_ = ''
            for text__content_ in child_.childNodes:
                supportedidentifier_ += text__content_.nodeValue
            self.supportedidentifier = supportedidentifier_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'componentinstantiationref':
            obj_ = componentinstantiationref.factory()
            obj_.build(child_)
            self.set_componentinstantiationref(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'findby':
            obj_ = findby.factory()
            obj_.build(child_)
            self.set_findby(obj_)
# end class componentsupportedinterface


class externalports(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, port=None):
        if port is None:
            self.port = []
        else:
            self.port = port
    def factory(*args_, **kwargs_):
        if externalports.subclass:
            return externalports.subclass(*args_, **kwargs_)
        else:
            return externalports(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_port(self): return self.port
    def set_port(self, port): self.port = port
    def add_port(self, value): self.port.append(value)
    def insert_port(self, index, value): self.port[index] = value
    portProp = property(get_port, set_port)
    def export(self, outfile, level, namespace_='', name_='externalports', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='externalports')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='externalports'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='externalports'):
        for port_ in self.port:
            port_.export(outfile, level, namespace_, name_='port')
    def hasContent_(self):
        if (
            self.port is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='externalports'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('port=[\n')
        level += 1
        for port in self.port:
            showIndent(outfile, level)
            outfile.write('model_.port(\n')
            port.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'port':
            obj_ = port.factory()
            obj_.build(child_)
            self.port.append(obj_)
# end class externalports


class port(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, usesidentifier=None, providesidentifier=None, supportedidentifier=None, componentinstantiationref=None):
        self.description = description
        self.usesidentifier = usesidentifier
        self.providesidentifier = providesidentifier
        self.supportedidentifier = supportedidentifier
        self.componentinstantiationref = componentinstantiationref
    def factory(*args_, **kwargs_):
        if port.subclass:
            return port.subclass(*args_, **kwargs_)
        else:
            return port(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_usesidentifier(self): return self.usesidentifier
    def set_usesidentifier(self, usesidentifier): self.usesidentifier = usesidentifier
    usesidentifierProp = property(get_usesidentifier, set_usesidentifier)
    def get_providesidentifier(self): return self.providesidentifier
    def set_providesidentifier(self, providesidentifier): self.providesidentifier = providesidentifier
    providesidentifierProp = property(get_providesidentifier, set_providesidentifier)
    def get_supportedidentifier(self): return self.supportedidentifier
    def set_supportedidentifier(self, supportedidentifier): self.supportedidentifier = supportedidentifier
    supportedidentifierProp = property(get_supportedidentifier, set_supportedidentifier)
    def get_componentinstantiationref(self): return self.componentinstantiationref
    def set_componentinstantiationref(self, componentinstantiationref): self.componentinstantiationref = componentinstantiationref
    componentinstantiationrefProp = property(get_componentinstantiationref, set_componentinstantiationref)
    def export(self, outfile, level, namespace_='', name_='port', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='port')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='port'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='port'):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.usesidentifier is not None:
            showIndent(outfile, level)
            outfile.write('<%susesidentifier>%s</%susesidentifier>\n' % (namespace_, self.format_string(quote_xml(self.usesidentifier).encode(ExternalEncoding), input_name='usesidentifier'), namespace_))
        if self.providesidentifier is not None:
            showIndent(outfile, level)
            outfile.write('<%sprovidesidentifier>%s</%sprovidesidentifier>\n' % (namespace_, self.format_string(quote_xml(self.providesidentifier).encode(ExternalEncoding), input_name='providesidentifier'), namespace_))
        if self.supportedidentifier is not None:
            showIndent(outfile, level)
            outfile.write('<%ssupportedidentifier>%s</%ssupportedidentifier>\n' % (namespace_, self.format_string(quote_xml(self.supportedidentifier).encode(ExternalEncoding), input_name='supportedidentifier'), namespace_))
        if self.componentinstantiationref:
            self.componentinstantiationref.export(outfile, level, namespace_, name_='componentinstantiationref', )
    def hasContent_(self):
        if (
            self.description is not None or
            self.usesidentifier is not None or
            self.providesidentifier is not None or
            self.supportedidentifier is not None or
            self.componentinstantiationref is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='port'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('usesidentifier=%s,\n' % quote_python(self.usesidentifier).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('providesidentifier=%s,\n' % quote_python(self.providesidentifier).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('supportedidentifier=%s,\n' % quote_python(self.supportedidentifier).encode(ExternalEncoding))
        if self.componentinstantiationref:
            showIndent(outfile, level)
            outfile.write('componentinstantiationref=model_.componentinstantiationref(\n')
            self.componentinstantiationref.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'description':
            description_ = ''
            for text__content_ in child_.childNodes:
                description_ += text__content_.nodeValue
            self.description = description_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'usesidentifier':
            usesidentifier_ = ''
            for text__content_ in child_.childNodes:
                usesidentifier_ += text__content_.nodeValue
            self.usesidentifier = usesidentifier_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'providesidentifier':
            providesidentifier_ = ''
            for text__content_ in child_.childNodes:
                providesidentifier_ += text__content_.nodeValue
            self.providesidentifier = providesidentifier_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'supportedidentifier':
            supportedidentifier_ = ''
            for text__content_ in child_.childNodes:
                supportedidentifier_ += text__content_.nodeValue
            self.supportedidentifier = supportedidentifier_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'componentinstantiationref':
            obj_ = componentinstantiationref.factory()
            obj_.build(child_)
            self.set_componentinstantiationref(obj_)
# end class port


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
Options:
    -s        Use the SAX parser, not the minidom parser.
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def parse(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = softwareassembly.factory()
    rootObj.build(rootNode)
    doc.unlink()
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="softwareassembly", 
##         namespacedef_='')
    return rootObj


def parseString(inString):
    doc = minidom.parseString(inString)
    rootNode = doc.documentElement
    rootObj = softwareassembly.factory()
    rootObj.build(rootNode)
    doc.unlink()
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="softwareassembly",
##         namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = softwareassembly.factory()
    rootObj.build(rootNode)
    doc.unlink()
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('from sad import *\n\n')
##     sys.stdout.write('rootObj = softwareassembly(\n')
##     rootObj.exportLiteral(sys.stdout, 0, name_="softwareassembly")
##     sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    main()
    #import pdb
    #pdb.run('main()')

