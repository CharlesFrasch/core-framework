#!/usr/bin/env python
#
# This file is protected by Copyright. Please refer to the COPYRIGHT file 
# distributed with this source distribution.
# 
# This file is part of REDHAWK core.
# 
# REDHAWK core is free software: you can redistribute it and/or modify it under 
# the terms of the GNU Lesser General Public License as published by the Free 
# Software Foundation, either version 3 of the License, or (at your option) any 
# later version.
# 
# REDHAWK core is distributed in the hope that it will be useful, but WITHOUT 
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
# 
# You should have received a copy of the GNU Lesser General Public License 
# along with this program.  If not, see http://www.gnu.org/licenses/.
#


#
# Generated Tue May 24 22:38:50 2011 by generateDS.py version 1.17d.REDHAWK.
#

import sys
import getopt
from string import lower as str_lower
from xml.dom import minidom
from xml.dom import Node

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper:
        def format_string(self, input_data, input_name=''):
            return input_data
        def format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def format_boolean(self, input_data, input_name=''):
            return '%s' % input_data


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class _MemberSpec(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type(self): return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


#
# Data representation classes.
#

class action(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=''):
        self.type_ = type_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if action.subclass:
            return action.subclass(*args_, **kwargs_)
        else:
            return action(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    type_Prop = property(get_type, set_type)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='action', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='action')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='', name_='action'):
        if self.type_ is not None:
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='', name_='action'):
        if self.valueOf_.find('![CDATA')>-1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='action'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('type'):
            self.type_ = attrs.get('type').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class action


class configurationKind(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, kindtype=None, valueOf_=''):
        self.kindtype = kindtype
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if configurationKind.subclass:
            return configurationKind.subclass(*args_, **kwargs_)
        else:
            return configurationKind(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_kindtype(self): return self.kindtype
    def set_kindtype(self, kindtype): self.kindtype = kindtype
    kindtypeProp = property(get_kindtype, set_kindtype)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='configurationKind', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='configurationKind')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='', name_='configurationKind'):
        if self.kindtype is not None:
            outfile.write(' kindtype=%s' % (quote_attrib(self.kindtype), ))
    def exportChildren(self, outfile, level, namespace_='', name_='configurationKind'):
        if self.valueOf_.find('![CDATA')>-1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='configurationKind'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.kindtype is not None:
            showIndent(outfile, level)
            outfile.write('kindtype = %s,\n' % (self.kindtype,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('kindtype'):
            self.kindtype = attrs.get('kindtype').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class configurationKind


class enumeration(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, label=None, valueOf_=''):
        self.value = value
        self.label = label
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if enumeration.subclass:
            return enumeration.subclass(*args_, **kwargs_)
        else:
            return enumeration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    valueProp = property(get_value, set_value)
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    labelProp = property(get_label, set_label)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='enumeration', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='enumeration')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='', name_='enumeration'):
        if self.value is not None:
            outfile.write(' value=%s' % (self.format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        outfile.write(' label=%s' % (self.format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='enumeration'):
        if self.valueOf_.find('![CDATA')>-1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='enumeration'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value = %s,\n' % (self.value,))
        if self.label is not None:
            showIndent(outfile, level)
            outfile.write('label = %s,\n' % (self.label,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('value'):
            self.value = attrs.get('value').value
        if attrs.get('label'):
            self.label = attrs.get('label').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class enumeration


class enumerations(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, enumeration=None):
        if enumeration is None:
            self.enumeration = []
        else:
            self.enumeration = enumeration
    def factory(*args_, **kwargs_):
        if enumerations.subclass:
            return enumerations.subclass(*args_, **kwargs_)
        else:
            return enumerations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enumeration(self): return self.enumeration
    def set_enumeration(self, enumeration): self.enumeration = enumeration
    def add_enumeration(self, value): self.enumeration.append(value)
    def insert_enumeration(self, index, value): self.enumeration[index] = value
    enumerationProp = property(get_enumeration, set_enumeration)
    def export(self, outfile, level, namespace_='', name_='enumerations', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='enumerations')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='enumerations'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='enumerations'):
        for enumeration_ in self.enumeration:
            enumeration_.export(outfile, level, namespace_, name_='enumeration')
    def hasContent_(self):
        if (
            self.enumeration is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='enumerations'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('enumeration=[\n')
        level += 1
        for enumeration in self.enumeration:
            showIndent(outfile, level)
            outfile.write('model_.enumeration(\n')
            enumeration.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'enumeration':
            obj_ = enumeration.factory()
            obj_.build(child_)
            self.enumeration.append(obj_)
# end class enumerations


class inputValue(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, simple=None):
        if simple is None:
            self.simple = []
        else:
            self.simple = simple
    def factory(*args_, **kwargs_):
        if inputValue.subclass:
            return inputValue.subclass(*args_, **kwargs_)
        else:
            return inputValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_simple(self): return self.simple
    def set_simple(self, simple): self.simple = simple
    def add_simple(self, value): self.simple.append(value)
    def insert_simple(self, index, value): self.simple[index] = value
    simpleProp = property(get_simple, set_simple)
    def export(self, outfile, level, namespace_='', name_='inputValue', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='inputValue')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='inputValue'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='inputValue'):
        for simple_ in self.simple:
            simple_.export(outfile, level, namespace_, name_='simple')
    def hasContent_(self):
        if (
            self.simple is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='inputValue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('simple=[\n')
        level += 1
        for simple in self.simple:
            showIndent(outfile, level)
            outfile.write('model_.simple(\n')
            simple.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'simple':
            obj_ = simple.factory()
            obj_.build(child_)
            self.simple.append(obj_)
# end class inputValue


class kind(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, kindtype=None, valueOf_=''):
        self.kindtype = kindtype
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if kind.subclass:
            return kind.subclass(*args_, **kwargs_)
        else:
            return kind(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_kindtype(self): return self.kindtype
    def set_kindtype(self, kindtype): self.kindtype = kindtype
    kindtypeProp = property(get_kindtype, set_kindtype)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='kind', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='kind')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='', name_='kind'):
        if self.kindtype is not None:
            outfile.write(' kindtype=%s' % (quote_attrib(self.kindtype), ))
    def exportChildren(self, outfile, level, namespace_='', name_='kind'):
        if self.valueOf_.find('![CDATA')>-1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='kind'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.kindtype is not None:
            showIndent(outfile, level)
            outfile.write('kindtype = "%s",\n' % (self.kindtype,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('kindtype'):
            self.kindtype = attrs.get('kindtype').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class kind


class properties(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, simple=None, simplesequence=None, test=None, struct=None, structsequence=None):
        self.description = description
        if simple is None:
            self.simple = []
        else:
            self.simple = simple
        if simplesequence is None:
            self.simplesequence = []
        else:
            self.simplesequence = simplesequence
        if test is None:
            self.test = []
        else:
            self.test = test
        if struct is None:
            self.struct = []
        else:
            self.struct = struct
        if structsequence is None:
            self.structsequence = []
        else:
            self.structsequence = structsequence
    def factory(*args_, **kwargs_):
        if properties.subclass:
            return properties.subclass(*args_, **kwargs_)
        else:
            return properties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_simple(self): return self.simple
    def set_simple(self, simple): self.simple = simple
    def add_simple(self, value): self.simple.append(value)
    def insert_simple(self, index, value): self.simple[index] = value
    simpleProp = property(get_simple, set_simple)
    def get_simplesequence(self): return self.simplesequence
    def set_simplesequence(self, simplesequence): self.simplesequence = simplesequence
    def add_simplesequence(self, value): self.simplesequence.append(value)
    def insert_simplesequence(self, index, value): self.simplesequence[index] = value
    simplesequenceProp = property(get_simplesequence, set_simplesequence)
    def get_test(self): return self.test
    def set_test(self, test): self.test = test
    def add_test(self, value): self.test.append(value)
    def insert_test(self, index, value): self.test[index] = value
    testProp = property(get_test, set_test)
    def get_struct(self): return self.struct
    def set_struct(self, struct): self.struct = struct
    def add_struct(self, value): self.struct.append(value)
    def insert_struct(self, index, value): self.struct[index] = value
    structProp = property(get_struct, set_struct)
    def get_structsequence(self): return self.structsequence
    def set_structsequence(self, structsequence): self.structsequence = structsequence
    def add_structsequence(self, value): self.structsequence.append(value)
    def insert_structsequence(self, index, value): self.structsequence[index] = value
    structsequenceProp = property(get_structsequence, set_structsequence)
    def export(self, outfile, level, namespace_='', name_='properties', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='properties')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='properties'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='properties'):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        for simple_ in self.simple:
            simple_.export(outfile, level, namespace_, name_='simple')
        for simplesequence_ in self.simplesequence:
            simplesequence_.export(outfile, level, namespace_, name_='simplesequence')
        for test_ in self.test:
            test_.export(outfile, level, namespace_, name_='test')
        for struct_ in self.struct:
            struct_.export(outfile, level, namespace_, name_='struct')
        for structsequence_ in self.structsequence:
            structsequence_.export(outfile, level, namespace_, name_='structsequence')
    def hasContent_(self):
        if (
            self.description is not None or
            self.simple is not None or
            self.simplesequence is not None or
            self.test is not None or
            self.struct is not None or
            self.structsequence is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='properties'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('simple=[\n')
        level += 1
        for simple in self.simple:
            showIndent(outfile, level)
            outfile.write('model_.simple(\n')
            simple.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('simplesequence=[\n')
        level += 1
        for simplesequence in self.simplesequence:
            showIndent(outfile, level)
            outfile.write('model_.simplesequence(\n')
            simplesequence.exportLiteral(outfile, level, name_='simplesequence')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('test=[\n')
        level += 1
        for test in self.test:
            showIndent(outfile, level)
            outfile.write('model_.test(\n')
            test.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('struct=[\n')
        level += 1
        for struct in self.struct:
            showIndent(outfile, level)
            outfile.write('model_.struct(\n')
            struct.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('structsequence=[\n')
        level += 1
        for structsequence in self.structsequence:
            showIndent(outfile, level)
            outfile.write('model_.structsequence(\n')
            structsequence.exportLiteral(outfile, level, name_='structsequence')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'description':
            description_ = ''
            for text__content_ in child_.childNodes:
                description_ += text__content_.nodeValue
            self.description = description_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'simple':
            obj_ = simple.factory()
            obj_.build(child_)
            self.simple.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'simplesequence':
            obj_ = simpleSequence.factory()
            obj_.build(child_)
            self.simplesequence.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'test':
            obj_ = test.factory()
            obj_.build(child_)
            self.test.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'struct':
            obj_ = struct.factory()
            obj_.build(child_)
            self.struct.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'structsequence':
            obj_ = structSequence.factory()
            obj_.build(child_)
            self.structsequence.append(obj_)
# end class properties


class range_(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, max=None, min=None, valueOf_=''):
        self.max = max
        self.min = min
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if range_.subclass:
            return range_.subclass(*args_, **kwargs_)
        else:
            return range_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_max(self): return self.max
    def set_max(self, max): self.max = max
    maxProp = property(get_max, set_max)
    def get_min(self): return self.min
    def set_min(self, min): self.min = min
    minProp = property(get_min, set_min)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='range', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='range')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='', name_='range'):
        outfile.write(' max=%s' % (self.format_string(quote_attrib(self.max).encode(ExternalEncoding), input_name='max'), ))
        outfile.write(' min=%s' % (self.format_string(quote_attrib(self.min).encode(ExternalEncoding), input_name='min'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='range'):
        if self.valueOf_.find('![CDATA')>-1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='range'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.max is not None:
            showIndent(outfile, level)
            outfile.write('max = %s,\n' % (self.max,))
        if self.min is not None:
            showIndent(outfile, level)
            outfile.write('min = %s,\n' % (self.min,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('max'):
            self.max = attrs.get('max').value
        if attrs.get('min'):
            self.min = attrs.get('min').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class range_


class resultValue(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, simple=None):
        if simple is None:
            self.simple = []
        else:
            self.simple = simple
    def factory(*args_, **kwargs_):
        if resultValue.subclass:
            return resultValue.subclass(*args_, **kwargs_)
        else:
            return resultValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_simple(self): return self.simple
    def set_simple(self, simple): self.simple = simple
    def add_simple(self, value): self.simple.append(value)
    def insert_simple(self, index, value): self.simple[index] = value
    simpleProp = property(get_simple, set_simple)
    def export(self, outfile, level, namespace_='', name_='resultValue', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='resultValue')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='resultValue'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='resultValue'):
        for simple_ in self.simple:
            simple_.export(outfile, level, namespace_, name_='simple')
    def hasContent_(self):
        if (
            self.simple is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='resultValue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('simple=[\n')
        level += 1
        for simple in self.simple:
            showIndent(outfile, level)
            outfile.write('model_.simple(\n')
            simple.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'simple':
            obj_ = simple.factory()
            obj_.build(child_)
            self.simple.append(obj_)
# end class resultValue


class simple(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, id_=None, name=None, mode=None, description=None, value=None, units=None, range_=None, enumerations=None, kind=None, action=None):
        self.type_ = type_
        self.id_ = id_
        self.name = name
        self.mode = mode
        self.description = description
        self.value = value
        self.units = units
        self.range_ = range_
        self.enumerations = enumerations
        if kind is None:
            self.kind = []
        else:
            self.kind = kind
        self.action = action
    def factory(*args_, **kwargs_):
        if simple.subclass:
            return simple.subclass(*args_, **kwargs_)
        else:
            return simple(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    valueProp = property(get_value, set_value)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    unitsProp = property(get_units, set_units)
    def validate_units(self, value):
        # validate type 3aaaa units
        pass
    def get_range(self): return self.range_
    def set_range(self, range_): self.range_ = range_
    rangeProp = property(get_range, set_range)
    def get_enumerations(self): return self.enumerations
    def set_enumerations(self, enumerations): self.enumerations = enumerations
    enumerationsProp = property(get_enumerations, set_enumerations)
    def get_kind(self): return self.kind
    def set_kind(self, kind): self.kind = kind
    def add_kind(self, value): self.kind.append(value)
    def insert_kind(self, index, value): self.kind[index] = value
    kindProp = property(get_kind, set_kind)
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    actionProp = property(get_action, set_action)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    type_Prop = property(get_type, set_type)
    def get_id(self): return self.id_
    def set_id(self, id_): self.id_ = id_
    id_Prop = property(get_id, set_id)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    modeProp = property(get_mode, set_mode)
    def export(self, outfile, level, namespace_='', name_='simple', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='simple')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='simple'):
        outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id_).encode(ExternalEncoding), input_name='id'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.mode is not None:
            outfile.write(' mode=%s' % (quote_attrib(self.mode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='simple'):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('<%svalue>%s</%svalue>\n' % (namespace_, self.format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_))
        if self.units is not None:
            showIndent(outfile, level)
            outfile.write('<%sunits>%s</%sunits>\n' % (namespace_, self.format_string(quote_xml(self.units).encode(ExternalEncoding), input_name='units'), namespace_))
        if self.range_:
            self.range_.export(outfile, level, namespace_, name_='range')
        if self.enumerations:
            self.enumerations.export(outfile, level, namespace_, name_='enumerations')
        for kind_ in self.kind:
            kind_.export(outfile, level, namespace_, name_='kind')
        if self.action:
            self.action.export(outfile, level, namespace_, name_='action')
    def hasContent_(self):
        if (
            self.description is not None or
            self.value is not None or
            self.units is not None or
            self.range_ is not None or
            self.enumerations is not None or
            self.kind is not None or
            self.action is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='simple'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.id_ is not None:
            showIndent(outfile, level)
            outfile.write('id_ = %s,\n' % (self.id_,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
        if self.mode is not None:
            showIndent(outfile, level)
            outfile.write('mode = "%s",\n' % (self.mode,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('units=%s,\n' % quote_python(self.units).encode(ExternalEncoding))
        if self.range_:
            showIndent(outfile, level)
            outfile.write('range_=model_.range_(\n')
            self.range_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.enumerations:
            showIndent(outfile, level)
            outfile.write('enumerations=model_.enumerations(\n')
            self.enumerations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('kind=[\n')
        level += 1
        for kind in self.kind:
            showIndent(outfile, level)
            outfile.write('model_.kind(\n')
            kind.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.action:
            showIndent(outfile, level)
            outfile.write('action=model_.action(\n')
            self.action.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('type'):
            self.type_ = attrs.get('type').value
        if attrs.get('id'):
            self.id_ = attrs.get('id').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('mode'):
            self.mode = attrs.get('mode').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'description':
            description_ = ''
            for text__content_ in child_.childNodes:
                description_ += text__content_.nodeValue
            self.description = description_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'value':
            value_ = ''
            for text__content_ in child_.childNodes:
                value_ += text__content_.nodeValue
            self.value = value_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'units':
            units_ = ''
            for text__content_ in child_.childNodes:
                units_ += text__content_.nodeValue
            self.units = units_
            self.validate_units(self.units)    # validate type 1aaaa units
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'range':
            obj_ = range_.factory()
            obj_.build(child_)
            self.set_range(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'enumerations':
            obj_ = enumerations.factory()
            obj_.build(child_)
            self.set_enumerations(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'kind':
            obj_ = kind.factory()
            obj_.build(child_)
            self.kind.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'action':
            obj_ = action.factory()
            obj_.build(child_)
            self.set_action(obj_)
# end class simple


class simpleRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, refid=None, value=None, valueOf_=''):
        self.refid = refid
        self.value = value
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if simpleRef.subclass:
            return simpleRef.subclass(*args_, **kwargs_)
        else:
            return simpleRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_refid(self): return self.refid
    def set_refid(self, refid): self.refid = refid
    refidProp = property(get_refid, set_refid)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    valueProp = property(get_value, set_value)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='simpleRef', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='simpleRef')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='', name_='simpleRef'):
        outfile.write(' refid=%s' % (self.format_string(quote_attrib(self.refid).encode(ExternalEncoding), input_name='refid'), ))
        outfile.write(' value=%s' % (self.format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='simpleRef'):
        if self.valueOf_.find('![CDATA')>-1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='simpleRef'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.refid is not None:
            showIndent(outfile, level)
            outfile.write('refid = %s,\n' % (self.refid,))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value = %s,\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = "%s",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('refid'):
            self.refid = attrs.get('refid').value
        if attrs.get('value'):
            self.value = attrs.get('value').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class simpleRef


class simpleSequence(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, id_=None, name=None, mode=None, description=None, values=None, units=None, range_=None, kind=None, action=None):
        self.type_ = type_
        self.id_ = id_
        self.name = name
        self.mode = mode
        self.description = description
        self.values = values
        self.units = units
        self.range_ = range_
        if kind is None:
            self.kind = []
        else:
            self.kind = kind
        self.action = action
    def factory(*args_, **kwargs_):
        if simpleSequence.subclass:
            return simpleSequence.subclass(*args_, **kwargs_)
        else:
            return simpleSequence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_values(self): return self.values
    def set_values(self, values): self.values = values
    valuesProp = property(get_values, set_values)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    unitsProp = property(get_units, set_units)
    def validate_units(self, value):
        # validate type 3aaaa units
        pass
    def get_range(self): return self.range_
    def set_range(self, range_): self.range_ = range_
    rangeProp = property(get_range, set_range)
    def get_kind(self): return self.kind
    def set_kind(self, kind): self.kind = kind
    def add_kind(self, value): self.kind.append(value)
    def insert_kind(self, index, value): self.kind[index] = value
    kindProp = property(get_kind, set_kind)
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    actionProp = property(get_action, set_action)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    type_Prop = property(get_type, set_type)
    def get_id(self): return self.id_
    def set_id(self, id_): self.id_ = id_
    id_Prop = property(get_id, set_id)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    modeProp = property(get_mode, set_mode)
    def export(self, outfile, level, namespace_='', name_='simplesequence', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='simplesequence')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='simplesequence'):
        outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id_).encode(ExternalEncoding), input_name='id'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.mode is not None:
            outfile.write(' mode=%s' % (quote_attrib(self.mode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='simplesequence'):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.values:
            self.values.export(outfile, level, namespace_, name_='values')
        if self.units is not None:
            showIndent(outfile, level)
            outfile.write('<%sunits>%s</%sunits>\n' % (namespace_, self.format_string(quote_xml(self.units).encode(ExternalEncoding), input_name='units'), namespace_))
        if self.range_:
            self.range_.export(outfile, level, namespace_, name_='range')
        for kind_ in self.kind:
            kind_.export(outfile, level, namespace_, name_='kind')
        if self.action:
            self.action.export(outfile, level, namespace_, name_='action')
    def hasContent_(self):
        if (
            self.description is not None or
            self.values is not None or
            self.units is not None or
            self.range_ is not None or
            self.kind is not None or
            self.action is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='simplesequence'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.id_ is not None:
            showIndent(outfile, level)
            outfile.write('id_ = %s,\n' % (self.id_,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
        if self.mode is not None:
            showIndent(outfile, level)
            outfile.write('mode = "%s",\n' % (self.mode,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.values:
            showIndent(outfile, level)
            outfile.write('values=model_.values(\n')
            self.values.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('units=%s,\n' % quote_python(self.units).encode(ExternalEncoding))
        if self.range_:
            showIndent(outfile, level)
            outfile.write('range_=model_.range_(\n')
            self.range_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('kind=[\n')
        level += 1
        for kind in self.kind:
            showIndent(outfile, level)
            outfile.write('model_.kind(\n')
            kind.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.action:
            showIndent(outfile, level)
            outfile.write('action=model_.action(\n')
            self.action.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('type'):
            self.type_ = attrs.get('type').value
        if attrs.get('id'):
            self.id_ = attrs.get('id').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('mode'):
            self.mode = attrs.get('mode').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'description':
            description_ = ''
            for text__content_ in child_.childNodes:
                description_ += text__content_.nodeValue
            self.description = description_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'values':
            obj_ = values.factory()
            obj_.build(child_)
            self.set_values(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'units':
            units_ = ''
            for text__content_ in child_.childNodes:
                units_ += text__content_.nodeValue
            self.units = units_
            self.validate_units(self.units)    # validate type 1aaaa units
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'range':
            obj_ = range_.factory()
            obj_.build(child_)
            self.set_range(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'kind':
            obj_ = kind.factory()
            obj_.build(child_)
            self.kind.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'action':
            obj_ = action.factory()
            obj_.build(child_)
            self.set_action(obj_)
# end class simpleSequence


class struct(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id_=None, name=None, mode=None, description=None, simple=None, configurationkind=None):
        self.id_ = id_
        self.name = name
        self.mode = mode
        self.description = description
        if simple is None:
            self.simple = []
        else:
            self.simple = simple
        if configurationkind is None:
            self.configurationkind = []
        else:
            self.configurationkind = configurationkind
    def factory(*args_, **kwargs_):
        if struct.subclass:
            return struct.subclass(*args_, **kwargs_)
        else:
            return struct(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_simple(self): return self.simple
    def set_simple(self, simple): self.simple = simple
    def add_simple(self, value): self.simple.append(value)
    def insert_simple(self, index, value): self.simple[index] = value
    simpleProp = property(get_simple, set_simple)
    def get_configurationkind(self): return self.configurationkind
    def set_configurationkind(self, configurationkind): self.configurationkind = configurationkind
    def add_configurationkind(self, value): self.configurationkind.append(value)
    def insert_configurationkind(self, index, value): self.configurationkind[index] = value
    configurationkindProp = property(get_configurationkind, set_configurationkind)
    def get_id(self): return self.id_
    def set_id(self, id_): self.id_ = id_
    id_Prop = property(get_id, set_id)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    modeProp = property(get_mode, set_mode)
    def export(self, outfile, level, namespace_='', name_='struct', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='struct')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='struct'):
        outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id_).encode(ExternalEncoding), input_name='id'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.mode is not None:
            outfile.write(' mode=%s' % (quote_attrib(self.mode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='struct'):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        for simple_ in self.simple:
            simple_.export(outfile, level, namespace_, name_='simple')
        for configurationkind_ in self.configurationkind:
            configurationkind_.export(outfile, level, namespace_, name_='configurationkind')
    def hasContent_(self):
        if (
            self.description is not None or
            self.simple is not None or
            self.configurationkind is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='struct'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id_ is not None:
            showIndent(outfile, level)
            outfile.write('id_ = %s,\n' % (self.id_,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
        if self.mode is not None:
            showIndent(outfile, level)
            outfile.write('mode = "%s",\n' % (self.mode,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('simple=[\n')
        level += 1
        for simple in self.simple:
            showIndent(outfile, level)
            outfile.write('model_.simple(\n')
            simple.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('configurationkind=[\n')
        level += 1
        for configurationkind in self.configurationkind:
            showIndent(outfile, level)
            outfile.write('model_.configurationkind(\n')
            configurationkind.exportLiteral(outfile, level, name_='configurationkind')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('id'):
            self.id_ = attrs.get('id').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('mode'):
            self.mode = attrs.get('mode').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'description':
            description_ = ''
            for text__content_ in child_.childNodes:
                description_ += text__content_.nodeValue
            self.description = description_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'simple':
            obj_ = simple.factory()
            obj_.build(child_)
            self.simple.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'configurationkind':
            obj_ = configurationKind.factory()
            obj_.build(child_)
            self.configurationkind.append(obj_)
# end class struct


class structSequence(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id_=None, name=None, mode=None, description=None, struct=None, structvalue=None, configurationkind=None):
        self.id_ = id_
        self.name = name
        self.mode = mode
        self.description = description
        self.struct = struct
        if structvalue is None:
            self.structvalue = []
        else:
            self.structvalue = structvalue
        if configurationkind is None:
            self.configurationkind = []
        else:
            self.configurationkind = configurationkind
    def factory(*args_, **kwargs_):
        if structSequence.subclass:
            return structSequence.subclass(*args_, **kwargs_)
        else:
            return structSequence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_struct(self): return self.struct
    def set_struct(self, struct): self.struct = struct
    structProp = property(get_struct, set_struct)
    def get_structvalue(self): return self.structvalue
    def set_structvalue(self, structvalue): self.structvalue = structvalue
    def add_structvalue(self, value): self.structvalue.append(value)
    def insert_structvalue(self, index, value): self.structvalue[index] = value
    structvalueProp = property(get_structvalue, set_structvalue)
    def get_configurationkind(self): return self.configurationkind
    def set_configurationkind(self, configurationkind): self.configurationkind = configurationkind
    def add_configurationkind(self, value): self.configurationkind.append(value)
    def insert_configurationkind(self, index, value): self.configurationkind[index] = value
    configurationkindProp = property(get_configurationkind, set_configurationkind)
    def get_id(self): return self.id_
    def set_id(self, id_): self.id_ = id_
    id_Prop = property(get_id, set_id)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    nameProp = property(get_name, set_name)
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    modeProp = property(get_mode, set_mode)
    def export(self, outfile, level, namespace_='', name_='structsequence', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='structsequence')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='structsequence'):
        outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id_).encode(ExternalEncoding), input_name='id'), ))
        if self.name is not None:
            outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.mode is not None:
            outfile.write(' mode=%s' % (quote_attrib(self.mode), ))
    def exportChildren(self, outfile, level, namespace_='', name_='structsequence'):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.struct:
            self.struct.export(outfile, level, namespace_, name_='struct', )
        for structvalue_ in self.structvalue:
            structvalue_.export(outfile, level, namespace_, name_='structvalue')
        for configurationkind_ in self.configurationkind:
            configurationkind_.export(outfile, level, namespace_, name_='configurationkind')
    def hasContent_(self):
        if (
            self.description is not None or
            self.struct is not None or
            self.structvalue is not None or
            self.configurationkind is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='structsequence'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id_ is not None:
            showIndent(outfile, level)
            outfile.write('id_ = %s,\n' % (self.id_,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = %s,\n' % (self.name,))
        if self.mode is not None:
            showIndent(outfile, level)
            outfile.write('mode = "%s",\n' % (self.mode,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.struct:
            showIndent(outfile, level)
            outfile.write('struct=model_.struct(\n')
            self.struct.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('structvalue=[\n')
        level += 1
        for structvalue in self.structvalue:
            showIndent(outfile, level)
            outfile.write('model_.structvalue(\n')
            structvalue.exportLiteral(outfile, level, name_='structvalue')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('configurationkind=[\n')
        level += 1
        for configurationkind in self.configurationkind:
            showIndent(outfile, level)
            outfile.write('model_.configurationkind(\n')
            configurationkind.exportLiteral(outfile, level, name_='configurationkind')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('id'):
            self.id_ = attrs.get('id').value
        if attrs.get('name'):
            self.name = attrs.get('name').value
        if attrs.get('mode'):
            self.mode = attrs.get('mode').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'description':
            description_ = ''
            for text__content_ in child_.childNodes:
                description_ += text__content_.nodeValue
            self.description = description_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'struct':
            obj_ = struct.factory()
            obj_.build(child_)
            self.set_struct(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'structvalue':
            obj_ = structValue.factory()
            obj_.build(child_)
            self.structvalue.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'configurationkind':
            obj_ = configurationKind.factory()
            obj_.build(child_)
            self.configurationkind.append(obj_)
# end class structSequence


class structValue(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, simpleref=None):
        if simpleref is None:
            self.simpleref = []
        else:
            self.simpleref = simpleref
    def factory(*args_, **kwargs_):
        if structValue.subclass:
            return structValue.subclass(*args_, **kwargs_)
        else:
            return structValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_simpleref(self): return self.simpleref
    def set_simpleref(self, simpleref): self.simpleref = simpleref
    def add_simpleref(self, value): self.simpleref.append(value)
    def insert_simpleref(self, index, value): self.simpleref[index] = value
    simplerefProp = property(get_simpleref, set_simpleref)
    def export(self, outfile, level, namespace_='', name_='structValue', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='structValue')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='structValue'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='structValue'):
        for simpleref_ in self.simpleref:
            simpleref_.export(outfile, level, namespace_, name_='simpleref')
    def hasContent_(self):
        if (
            self.simpleref is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='structValue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('simpleref=[\n')
        level += 1
        for simpleref in self.simpleref:
            showIndent(outfile, level)
            outfile.write('model_.simpleref(\n')
            simpleref.exportLiteral(outfile, level, name_='simpleref')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'simpleref':
            obj_ = simpleRef.factory()
            obj_.build(child_)
            self.simpleref.append(obj_)
# end class structValue


class test(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id_=None, description=None, inputvalue=None, resultvalue=None):
        self.id_ = id_
        self.description = description
        self.inputvalue = inputvalue
        self.resultvalue = resultvalue
    def factory(*args_, **kwargs_):
        if test.subclass:
            return test.subclass(*args_, **kwargs_)
        else:
            return test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    descriptionProp = property(get_description, set_description)
    def get_inputvalue(self): return self.inputvalue
    def set_inputvalue(self, inputvalue): self.inputvalue = inputvalue
    inputvalueProp = property(get_inputvalue, set_inputvalue)
    def get_resultvalue(self): return self.resultvalue
    def set_resultvalue(self, resultvalue): self.resultvalue = resultvalue
    resultvalueProp = property(get_resultvalue, set_resultvalue)
    def get_id(self): return self.id_
    def set_id(self, id_): self.id_ = id_
    id_Prop = property(get_id, set_id)
    def export(self, outfile, level, namespace_='', name_='test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='test')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='test'):
        outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id_).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='test'):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.inputvalue:
            self.inputvalue.export(outfile, level, namespace_, name_='inputvalue')
        if self.resultvalue:
            self.resultvalue.export(outfile, level, namespace_, name_='resultvalue', )
    def hasContent_(self):
        if (
            self.description is not None or
            self.inputvalue is not None or
            self.resultvalue is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id_ is not None:
            showIndent(outfile, level)
            outfile.write('id_ = %s,\n' % (self.id_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.inputvalue:
            showIndent(outfile, level)
            outfile.write('inputvalue=model_.inputValue(\n')
            self.inputvalue.exportLiteral(outfile, level, name_='inputvalue')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.resultvalue:
            showIndent(outfile, level)
            outfile.write('resultvalue=model_.resultValue(\n')
            self.resultvalue.exportLiteral(outfile, level, name_='resultvalue')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('id'):
            self.id_ = attrs.get('id').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'description':
            description_ = ''
            for text__content_ in child_.childNodes:
                description_ += text__content_.nodeValue
            self.description = description_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'inputvalue':
            obj_ = inputValue.factory()
            obj_.build(child_)
            self.set_inputvalue(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'resultvalue':
            obj_ = resultValue.factory()
            obj_.build(child_)
            self.set_resultvalue(obj_)
# end class test


class values(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None):
        if value is None:
            self.value = []
        else:
            self.value = value
    def factory(*args_, **kwargs_):
        if values.subclass:
            return values.subclass(*args_, **kwargs_)
        else:
            return values(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    valueProp = property(get_value, set_value)
    def export(self, outfile, level, namespace_='', name_='values', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s' % (namespace_, name_, ))
        if len(namespacedef_) > 0: outfile.write('%s' % (namespacedef_, ))
        self.exportAttributes(outfile, level, namespace_, name_='values')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write(' />\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='values'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='values'):
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('<%svalue>%s</%svalue>\n' % (namespace_, self.format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_))
    def hasContent_(self):
        if (
            self.value is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='values'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'value':
            value_ = ''
            for text__content_ in child_.childNodes:
                value_ += text__content_.nodeValue
            self.value.append(value_)
# end class values


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
Options:
    -s        Use the SAX parser, not the minidom parser.
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def parse(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = properties.factory()
    rootObj.build(rootNode)
    doc.unlink()
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="properties", 
##         namespacedef_='')
    return rootObj


def parseString(inString):
    doc = minidom.parseString(inString)
    rootNode = doc.documentElement
    rootObj = properties.factory()
    rootObj.build(rootNode)
    doc.unlink()
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('<?xml version="1.0" ?>\n')
##     rootObj.export(sys.stdout, 0, name_="properties",
##         namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = properties.factory()
    rootObj.build(rootNode)
    doc.unlink()
    # Enable Python to collect the space used by the DOM.
    doc = None
##     sys.stdout.write('from prf import *\n\n')
##     sys.stdout.write('rootObj = properties(\n')
##     rootObj.exportLiteral(sys.stdout, 0, name_="properties")
##     sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    main()
    #import pdb
    #pdb.run('main()')

