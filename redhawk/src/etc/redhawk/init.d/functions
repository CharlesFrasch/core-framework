#!/bin/bash

###############################################
#  /etc/init.d/function overrides..
###############################################

import_os_functions () {
if [ -f /etc/redhat-release ];
then
    if [ -f /etc/init.d/functions  ];
    then 
        . /etc/init.d/functions        
        _rh_failure="failure"
        _rh_success="success"
    fi
fi
if [ -f /etc/lsb-release ];
then
   . /lib/lsb/init-functions
   _rh_failure="log_failure_msg"
   _rh_success="log_success_msg"
fi
}

rh_success() {
  $_rh_success
  echo ""
}

rh_failure() {
  $_rh_failure
  echo ""
}



rh_return() {
    local retval_=$1
    local cnt_=$2
            
    if [[ $cnt_ < 2 ]]
    then
        [ $retval_ -eq 0 ] && rh_success || rh_failure
        return $1
    else
        return 0
    fi
}

#####################################################
#   Helpers for lists, searching, named arrays
#####################################################


#
#  Search for $2 contained in a $1 list 
#
#  0: found item in list
#  1: item not found in list
#
contains()
{
  [[ $1 =~ (^|[[:space:]])"$2"($|[[:space:]]) ]] && return 0 || return 1
}


#
#  Search for $2 in a $1 list
#
#  1: found item in list
#  0: item not found in list
#
not_in_list()
{
  [[ -z $1 ]] && return 1
  contains $1 "$2"  && return 1 || return 0
}


#
# take a comma separate list and turn into an array of strings
#
string_to_list() {
    local array_="$1"
    local src_="$2"
    unset tlist_
    unset IFS
    local tlist_
    IFS="," read -r -a tlist_ <<< "$src_"
    unset IFS
    for ((i=0; i < ${#tlist_[@]}; i ++ )) 
    do
        v="${tlist_[$i]}"
        v="${v%"${v##*[![:space:]]}"}"
        v="${v#"${v%%[![:space:]]*}"}"
        if [[ $v =~ .*\".* ]]
        then
            #eval "$array_+=(\"${v//\"/\\\'}\")"
            eval "$array_+=(\"${v//\"/\\\"} \")"
        else
	    eval "$array_+=(\"$v\")"
        fi
    done
}


#
# Search a list of strings looking for a match
#
# param:
#   1 : array of strings
#   2 : string to look for
#
# return:
#  0 : match found
#  1 : no match found
#
list_contains()
{
  [ -z $1 ] && return 1
  name=$1[@]
  b=$2
  a=("${!name}")

  for i in "${a[@]}" ; do
      if [[ $i =~ ^$2$ ]]
      then
	  return 0
      fi
  done
  return 1
}

#
# Search a list of strings looking for a match
#
# param:
#   1 : array of strings
#   2 : string to look for
#
# return:
#  1 : match found
#  0 : no match found
#
list_does_not_contain()
{
  list_contains $1 "$2" && return 1 || return 0
}


#
# check_key
#
# check if key exists is in named array 
#
# $1 named array to be evaluated
# $2 key to look up
# 
# 0 : key found and has item
# 1 : item not found
array_has_key() {
    local key_="${2^^}"
    local e="$( declare -p $1)"
    eval "declare -A E=${e#*=}"
    contains "${!E[*]}" "$key_"
    return $?
}

#
# array_check_item
#
# perform check of item in a named array 
#
# $1 named array to  be evaluated
# $2 key to look up
# 
# 0 : key found and has item
# 1 : item not found
array_check_item() {
    local key_="${2^^}"
    local e="$( declare -p $1)"
    eval "declare -A E=${e#*=}"
    if [[ -z "${E[${key_}]}" ]]; then return 1; else return 0; fi
}

#
# array_get_item
#
# get an iem from a named array an return 0
#
# $1 named array to be evaluated
# $2 key to look up
# 
# returns: contents of named array[$2]
# 0 : key found and has item
# 1 : item not found
array_get_item() {
    local key_="${2^^}"
    local e="$( declare -p $1)"
    eval "declare -A E=${e#*=}"
    if [[ -z "${E[${key_}]}" ]]; 
    then 
        return 1;
    else
        echo ${E[${key_}]};
        return 0;
    fi
}


#
# resolve_item
#
# get item from array, if item is not
# defined or found return 1
#
# $1 named array
# $2 item to retrieve
#
# return code:
# 0 : list contains $2
#       echo $1[$2]
# 1: $2 not found in array or unset
resolve_item() {
    local cval_
    cval_=$(array_get_item $1 $2)
    if [[ $? != 0 ]] ;
    then
        return 1
    fi
    
    if [ -z "$cval_" ];
    then
        return 1
    fi
    echo "$cval_"
    return 0
}


#
# resolve_item_defaults
#
# $1 named array
# $2 item to retrieve
# $3 named array with defaults
#
# if $1 named array contains $2 then
# return its contents. Otherwise return
# the contents of $3[$2], or fallback to blank
resolve_item_defaults() {
    local cval_
    local dval_
    cval_=$(array_get_item $1 $2)
    if [ $? -ne 0 ];
    then
        unset cval_
    fi
    
    if [ -z $cval_ ];
    then
        dval_=$(array_get_item $3 $2)
        cval_="$dval_"
        if [ $? -ne 0 ];
        then
            cval_=""
        fi
    fi
    echo "$cval_"
    
}

#
# resolve_optional_item_defaults
#
# $1 named array
# $2 item to retrieve
# $3 named array with defaults
#
# return code:
# 1 : item not found or not set in default array
# 0 : item was resolved
# stdout:
#   return $1[$2] if set or default $3[$2]
resolve_optional_item_defaults() {
    local cval_
    local dval_
    cval_=$(array_get_item $1 $2)
    if [ $? -ne 0 ];
    then
        unset cval_
    fi
    
    if [ -z $cval_ ];
    then
        dval_=$(array_get_item $3 $2)
        if [ $? -ne 0 ];
        then
            return 1
        fi
        cval_=$dval_
    fi
    echo "$cval_"
    return 0
    
}

######################################################################
#  Ini file Helpers
######################################################################


# Load sections:
#
# load section names in a list, handles section names with spaces
#
# required:
#  declare -a section_list
#
load_cfg_sections() {
    local section_list_="section_list"
    [[ $# > 1 ]] && section_list_="$2"
    while read sec 
    do
	eval "$section_list_+=("$sec")"
    done< <(crudini --get --format=sh "$1")
}


#  read file that contains Name=Value pairs, create variables 
# in the global context and assigns values using the file contents
# 
# $1 : file to read from
# Name: is the name of the variable to create/assign
# Value: value to assign to the varible
#
create_cfg_defaults() 
{
  local k=
  local v=
  if [ -f $1 ];
  then
    while read dline ;
    do
      [ -z $dline ] && continue
      [[ $dline =~ ^#.*$ ]] && continue
       k=${dline%=*}
       v=${dline#*=}
       printf -v  $k "$v"
    done<"$1"
  fi
}


#
# From a file ($1), grab a specific ini section ($2) and load into pre-declared named array passed as arg $3
#
get_ini_section() {
    local cfg_file_="$1"
    local section_=""
    local cfg_array_="cfg"
    [[ $# > 1 ]] && section_="$2"
    [[ $# > 2 ]] && cfg_array_="$3"

    [[  _rh_debug_ ]] || echo "Processing CFG: \"${section_}\" in cfg: \"${cfg_file_}\""
    # Load all default configuration setting
    eval $(crudini --get --format=sh "$cfg_file_" "$section_"  | sed "s/\([^=]*\)=/$cfg_array_\[\U\1\]=/; s/ = /=/;")
}


get_config_section() {
    load_cfg_with_overrides $*
    resolve_redhawk_env
    return $?
}

load_cfg_with_overrides() {
    
    local cfg_file_=$1
    local section_=$2
    local cfg_defaults_=$3

    unset default_cfg
    unset ovr_cfg
    unset t_cfg
    [[  _rh_debug_ ]] || echo "get_config_section, Section: \"${section_}\"  CFG: \"${cfg_file_}\""

    eval $(crudini --get --format=sh "$cfg_file_" "$section_")
    [[ $? != 0 ]] &&  return 1

    # Load all default configuration setting
    declare -A default_cfg
    declare -A ovr_cfg
    declare -A t_cfg
    eval $(crudini --get --format=sh $cfg_defaults_ ""  | sed 's/\([^=]*\)=/default_cfg\[\U\1\]=/; s/ = /=/;')
    eval $(crudini --get --format=sh "$cfg_file_" "$section_"  | sed 's/\([^=]*\)=/ovr_cfg\[\U\1\]=/; s/ = /=/;')

    # merge configurations together
    src="$(declare -p default_cfg)"
    ovr="$(declare -p ovr_cfg)"
    # create a declare statement with combined contents of both arrays, magic numbers strip off extra statements
    # so lists can be combined
    cfg_merge="${src:0:${#src}-3} ${ovr:21}"
    eval "declare -A t_cfg=${cfg_merge#*=}"
    for kv in "${!t_cfg[@]}"
    do 
	cfg["$kv"]="${t_cfg["$kv"]}"
    done

    return $?
}


#
# Search a directory of ini files looking for a specific key=value pair
#
search_config_section() {
    local match_=$1
    local key_=${2^^}
    local cfg_dir=$3
    local cfg_defaults=$4
    local cfg_files_
    local section_list_

    cfg_files_=$(shopt -s nullglob dotglob; echo ${cfg_dir}/[^.]*[^~])
    for cfg_file in $cfg_files_
    do
	unset section_list
	declare -a section_list
        load_cfg_sections $cfg_file
	for section in "${section_list[@]}"
	do
            unset default_cfg
            unset ovr_cfg
            unset t_cfg

            [[ $_rh_debug_ ]] && echo "Processing section: \"${section}\" in cfg: \"${cfg_file}\""

	    # Load all default configuration setting
	    declare -A default_cfg
	    declare -A ovr_cfg
	    declare -A t_cfg
	    eval $(crudini --get --format=sh $cfg_defaults ""  | sed 's/\([^=]*\)=/default_cfg\[\U\1\]=/; s/ = /=/;')
	    eval $(crudini --get --format=sh "$cfg_file" "$section"  | sed 's/\([^=]*\)=/ovr_cfg\[\U\1\]=/; s/ = /=/;')

	    # merge configurations together
	    src="$(declare -p default_cfg)"
	    ovr="$(declare -p ovr_cfg)"
	    # create a declare statement with combined contents of both arrays, magic numbers strip off extra statements
	    # so lists can be combined
	    cfg_merge="${src:0:${#src}-3} ${ovr:21}"
	    eval "declare -A t_cfg=${cfg_merge#*=}"

	    val=$(resolve_item t_cfg "$key_")
	    if [ $? -eq 0 ];
	    then
                if [[ $val == $match_ ]];
		then
		    for kv in "${!t_cfg[@]}"
		    do 
			cfg["$kv"]="${t_cfg["$kv"]}"
		    done
		    return 0
		 fi
            fi
	done

    done
    return 1
}

resolve_enabled() {
    # assums cfg is loaded
    local svc_name="$1"
    local enabled_value="$2"
    local cond_cfg_file="$3"

    #  default,  no enabled value then service is enable
    [[ -n $enabled_value ]] || return 0
    [[ -z $enabled_value ]] && return 0

    check_true_value "$enabled_value" && return 0

    check_false_value "$enabled_value" && return 1

    declare -f conditional_enabled >/dev/null
    ret=$?
    if [[ $ret == 0 ]]
    then
        # enabled_value contains other value .. call conditional_enabled function 
        $(conditional_enabled "$svc_name" "$enabled_value" "$cond_cfg_file")
        ret=$?
    fi
    return $ret
}



#
# svc_enabled
#
# search ini files in a configuration directory for service that 
# matches $1 and is enabled
# 
# $1 - value to match on
# $2 - directory to search ini files
# $3 - key to look for to match $1 against
# $4 - key to resolved for enabled
#
svc_enabled() {
    local svc_match_=$1
    local cfg_dir_=$2
    local svc_key_=${3^^}
    local svc_enabled_key_="ENABLE"
    local svc_cond_cfg_key_="COND_CFG"
    local cfg_files_
    local section_list_
    if [ $# -gt 3 ];
    then
        svc_enabled_=${4^^}
    fi

    cfg_files_=$(shopt -s nullglob dotglob; echo $cfg_dir_/[^.]*[^~])
    for cfg_file in ${cfg_files_}
    do
        [[ $_rh_debug_ ]] && echo "Processing cfg: ${cfg_file}"
        unset section_list_
	declare -a section_list_=()
        while read sec 
        do
	    section_list_+=("$sec")
        done< <(crudini --get --format=sh $cfg_file)
	for section in "${section_list_[@]}"
        do
            [[ $_rh_debug_ ]] && echo "Processing section: \"${section}\" in cfg: \"${cfg_file}\""
            #Required Field
            local svc_name_
            local svc_enabled_
            local svc_cond_cfg_
            svc_name_=$(crudini --get "${cfg_file}" "${section}" $svc_key_ 2>/dev/null)
            svc_enabled_=$(crudini --get "${cfg_file}" "${section}" $svc_enabled_key_ 2>/dev/null)
            svc_cond_cfg_=$(crudini --get "${cfg_file}" "${section}" $svc_cond_cfg_key_ 2>/dev/null)
            if [[ $svc_name_ == $svc_match_ ]]
            then
                [[ $_rh_debug_ ]] && echo "service name " $svc_name_ " = " $svc_match_
                [[ $_rh_debug_ ]] && echo "enable value " $svc_enabled_
                resolve_enabled "$svc_name_" "$svc_enabled_" "$svc_cond_cfg_"
                return $?
            fi
            
        done

    done

    return 2
}





####################################################
#  File naming helpers
####################################################

#
# Remove extension and path from a file name
#
file_remove_ext(){
    local filename
    local ext=".$2"
    local extlen=${#ext}
    filename=$(basename $1)
    [ ${#filename} -ge $extlen ] && echo ${filename:0:${#filename}-$extlen}  || echo $filename
}


#
# Remove .pid from pid files
#
pidfile_remove_ext(){
    file_remove_ext $1 "pid"
}

#
# Remove .lock from pid files
#
lockfile_remove_ext(){
    file_remove_ext $1 "lock"
}

#
# Create pid file name from $1
#
pidfile_name(){
    local ddir_=$PID_DIR
    local bname="$1"
    if [ "$1" = "-d" ]; then
	ddir_=$2
	shift 2
    fi
    echo $ddir_/$bname.pid
}


#
# Create lock file name from $1
#
lockfile_name(){
    local ddir_=$LOCK_DIR
    local bname="$1"
    if [ "$1" = "-d" ]; then
	ddir_=$2
	shift 2
    fi
    echo $ddir_/$bname.lock
}



#
# Check if $1 is false or 0
#
check_false_value() {
    local lc=${1^^}

    if [[ $lc =~ ^(0|FALSE)$ ]] ;
    then
        return 0
    else
        return 1
    fi
} 

#
# Check if $1 is true or 1
#
check_true_value() {
    local lc=${1^^}

    if [[ $lc =~ ^(1|TRUE)$ ]] ;
    then
        return 0
    else
        return 1
    fi
} 


#
# Convert text based debug level to cmd line arg
#
debug_name_to_number() {
    local lc=${1^^}
    case $lc in
        FATAL) 
            echo "0" ;
            return 0 ;;
        ERROR) 
            echo "1" ;
            return 0 ;;
        WARN)
            echo "2" ;
            return 0 ;;
        INFO)
            echo "3" ;
            return 0 ;;
        DEBUG) 
            echo "4" ;
            return 0 ;;
        TRACE) 
            echo "5" ;
            return 0 ;;
        *)  
            echo "3" ;
            return 0 ;;
    esac
    echo ""
    return 1 
}


resolve_redhawk_env() {
    # assumes cfg already declared as named array
    local val
    local tmp_
    local sdrroot="/var/redhawk/sdr"
    
    tmp_=""
    val=$(resolve_item cfg "sdrroot")
    if [ $? -ne 0 ];
    then
        if [[ -z "$SDRROOT" ]];
        then
             echo "Missing SDRROOT from environment and config file" && return 1
        else
            SDRROOT_="$SDRROOT"
            cfg["SDRROOT"]="$SDRROOT"
         fi
    else
        tmp_=`eval "echo $val"`
        sdrroot="$tmp_"
        cfg["SDRROOT"]="$tmp_"
	SDRROOT_="$tmp_"
    fi

    unset val
    tmp_=""
    val=$(resolve_item cfg "ossiehome")
    if [ $? -ne 0 ];
    then
        if [[ -z "$OSSIEHOME" ]];
        then
             echo "Missing OSSIEHOME from environment and config file" && return 1
        else
            OSSIEHOME_="$OSSIEHOME"
            cfg["OSSIEHOME"]="$OSSIEHOME"
         fi
    else
        tmp_=`eval "echo $val"`
        ossiehome="$tmp_"
        cfg["OSSIEHOME"]="$tmp_"
	OSSIEHOME_="$tmp_"
    fi

}


check_pid_dir() {
    local pid_dir_=${PID_DIR}
    [ -z $pid_dir_  ] && echo "PID_DIR not set " && return 1
    [ -d $pid_dir_ ] && return 0 || echo "PID_DIR does not exists: $pid_dir_" && return 1
}

get_pid_files() {
    local pid_files_
    local pid_dir
    pid_dir=$1
    pid_files_=$(shopt -s nullglob dotglob; echo $pid_dir/*) 
    pid_files=($pid_files_)
}


#
# Run all the scripts in a specified directory.. ignores return codes
#
run_scripts()
{
  SCRIPT_FILES=$(shopt -s nullglob dotglob; echo ${1}/* )
  for script in ${SCRIPT_FILES}
  do
     echo "Running Script: $script"
     . "$script"
  done
}


#
#
# Check if a process is running, accepts a 2 parameters:
# A pid file that contains the process id and the expected
# proces name (optional, if not use environment PROCNAME)
# 
# $1 name of pid file to read
# $2 name of process to match on, or use PROCNAME
#
check_run() {

    if [[ -z $1 || ! -f $1 ]]; then return 1; fi
    local pname
    local pid
    local rpids
    
    if [ $# -gt 1 ];
    then
        pname="$2"
    else
        pname="${EXEC}"
    fi

    read pid < ${1}

    [[ ! $pid ]] && return 2
    [[ -z $pid ]] && return 2
		
    # Get matching running pids using "pidof". Compares against executable name to ensure validity after a reboot
    rpids=`pidof -o $$ -o $PPID -o %PPID -x $1 || \
	pidof -o $$ -o $PPID -o %PPID -x $pname`
		
    # Check matching against pid in pid file
    if [ -n "$pid" ] && [ -n "$rpids" ] ; then
	for p in $rpids
	do
	    if [ "$p" = "$pid" ]; then
		return 0
	    fi
	done
    fi
	
    return 1
}





build_exec_options() {
    #
    # assumes cfg exec_options are already declared as declare -A
    #
    local outfile_=$1
    local pidfile_=$2
    local val
    local tmp_
    local sdrroot="/var/redhawk/sdr"
    local rh_env_path_=""
    
    # process any environment settings.. save to file to allow for spaces in values
    local tmpfile_=""
    tmpfile_=$(mktemp /tmp/rh-env-init.XXXXXX)
    chmod guo+r "$tmpfile_"
    exec 4>"$tmpfile_"
    # add required redhawk environment variables


    tmp_=""
    local SDRROOT_=""
    val=$(resolve_item cfg "sdrroot")
    if [[ $? == 0 ]] ;
    then
        tmp_=`eval "echo $val"`
        sdrroot="$tmp_"
        exec_options["SDRROOT"]="$tmp_"
	SDRROOT_="$tmp_"
	echo "export SDRROOT=${exec_options["SDRROOT"]}" >&4
    fi
    rh_env_path_="SDRROOT=$tmp_"
    local SDRROOT="$SDRROOT_"

    tmp_=""
    OSSIEHOME_=""
    val=$(resolve_item cfg "ossiehome")
    if [[ $? == 0 ]] ;
    then
        tmp_=`eval "echo $val"`
        exec_options["OSSIEHOME"]="$tmp_"
	OSSIEHOME_="$tmp_"
	echo "export OSSIHOME=${exec_options["OSSIEHOME"]}" >&4
    fi
    rh_env_path_="$rh_env_path_ OSSIEHOME=$OSSIEHOME_ "
    local OSSIEHOME="$OSSIEHOME_"

    tmp_=""
    local LD_LIBRARY_PATH_=""
    val=$(resolve_item cfg "ld_library_path")
    if [[ $? == 0 ]] ;
    then
        tmp_=`eval "echo $val"`
        exec_options["LD_LIBRARY_PATH"]="$tmp_"
	LD_LIBRARY_PATH_="LD_LIBRARY_PATH=$tmp_"
	echo "export LD_LIBRARY_PATH=${exec_options["LD_LIBRARY_PATH"]}" >&4
    fi

    tmp_=""
    local PYTHONPATH_=""
    val=$(resolve_item cfg "pythonpath")
    if [[ $? == 0 ]] ;
    then
        tmp_=`eval "echo $val"`
        exec_options["PYTHONPATH"]="$tmp_"
	PYTHONPATH_="PYTHONPATH=$tmp_"
	echo "export PYTHONPATH=${exec_options["PYTHONPATH"]}" >&4
    fi

    tmp_=""
    local PATH_=""
    val=$(resolve_item cfg "path")
    if [[ $? == 0 ]] ;
    then
        tmp_=`eval "echo $val"`
        exec_options["PATH"]="$tmp_"
	PATH_="PATH=$tmp_"
	echo "export PATH=${exec_options["PATH"]}" >&4
    fi

    tmp_=""
    local JAVA_HOME_=""
    val=$(resolve_item cfg "java_home")
    if [[ $? == 0 ]] ;
    then
        tmp_=`eval "echo $val"`
        exec_options["JAVA_HOME"]="$tmp_"
	JAVA_HOME_="JAVA_HOME=$tmp_"
	echo "export JAVA_HOME=${exec_options["JAVA_HOME"]}" >&4
    fi

    rh_env_path_="$rh_env_path_ $LD_LIBRARY_PATH_  $PYTHONPATH_ $JAVA_HOME_ "

    val=$(resolve_item cfg "user")
    if [[ $? == 0 ]] ;
    then
        exec_options["USER"]="$val"
    else
        exec_options["USER"]="redhawk"
    fi

    unset val
    val=$(resolve_item cfg "group")
    if [[ $? == 0 ]] ;
    then
        exec_options["GROUP"]="$val"
    else
        exec_options["GROUP"]="redhawk"
    fi

    # process ULIMIT and CORE_FILES options
    tmp_=""
    val=$(resolve_item cfg "core_files")
    if [[ $? == 0 ]] ;
    then
	if [ "$val" == "1" ];
	then 
	    tmp_="-c unlimited"
	else
	    tmp_="-c 0"
	fi
   fi

    tmp_=""
    unset val
    val=$(resolve_item cfg "ulimit")
    if [[ $? == 0 ]] ;
    then
	tmp_="$tmp_ $val"
    fi

    [[ ! -z $tmp_ ]] && exec_options["ULIMIT"]="ulimit $tmp_ >/dev/null 2>&1;"

    unset val
    val=$(resolve_item cfg "NICELEVEL")
    if [[ $? == 0 ]] ;
    then
	tmp_="$tmp_ $val"
        exec_options["NICELEVEL"]="nice -n $val "
    fi

    unset val
    val=$(resolve_item cfg "CGROUP")
    if [[ $? == 0 ]] ;
    then
        exec_options["CGROUP"]="/bin/cgexec -g $val "
    fi

    tmp_=""
    local rundir_
    val=$(resolve_item cfg "rundir")
    if [[ $? == 0 ]] ;
    then
        rundir_=`eval "echo $val"`
	tmp_="cd $rundir_;"
    else
	tmp_="cd $sdrroot;"
	rundir_="$sdrroot" 
    fi
    exec_options["RUNDIR"]="$tmp_"
    # if rundir does not exists create directory
    [ -d $rundir_ ] || mkdir -p $rundir_ && chmod guo+rwx $rundir_

    [[ $pidfile_ ]] && exec_options["PIDFILE"]="$pidfile_"

    # capture output to file
    local oprefix_=$(resolve_item cfg "output_prefix")
    unset val
    local outfile="/dev/null"
    val=$(resolve_item cfg "output")
    if [[ $? != 0 ]] ;
    then 
        outfile="${LOG_OUT_DIR}/$oprefix_.$outfile_.log"
    elif [[ $val =~ ^\/.*$ ]] ;
    then
        tmp_=`eval "echo $val"`
        outfile="$tmp_"
    else
        # expand any environment variables or names
        tmp_=`eval "echo $val"`
        outfile="${LOG_OUT_DIR}/$tmp_"
    fi
    exec_options["OUTPUT"]="$outfile"

    unset val
    val=$(resolve_item cfg "OUTPUT_REDIRECT")
    if [[ $? == 0 ]] ;
    then
        exec_options["OUTPUT_REDIRECT"]="$val"
    fi

    unset val
    val=$(resolve_item cfg "permissions_start_only")
    if [[ $? == 0 ]] ;
    then
        if check_true_value $val ;
        then
           exec_options["PERMISSIONS_START_ONLY"]=1
        else
           exec_options["PERMISSIONS__START_ONLY"]=0
        fi
    fi

    unset val
    val=$(resolve_item cfg "affinity")
    if [[ $? == 0 ]] ;
    then
        val="$val "
        exec_options["AFFINITY"]="$val"
    fi
    exec_options["AFFINITY"]="$val"

    local orb_cfg_""
    unset val
    val=$(resolve_item cfg "orb_cfg")
    if [[ $? == 0 ]] ;
    then
        orb_cfg_=`eval "echo $val"`
        exec_options["ORB_CFG"]="OMNIORB_CONFIG=$orb_cfg_"
    fi

    # process any environment settings.. save to file to allow for spaces in values
    tmp_=""
    unset val
    val=$(resolve_item cfg "environment")
    if [[ $? == 0 ]] ;
    then
        val=${val//\"/\\\"}
        tmp_=`eval "echo $val"`

        unset tlist
        declare -a tlist=()
        string_to_list tlist "$tmp_"

        tmp_=""
        for ((i=0; i < ${#tlist[@]}; i++ )) 
        do
            tmp_="$tmp_ ${tlist[$i]}"
	    echo "export ${tlist[$i]}" >&4
        done
    fi
    exec_options["ENVIRONMENT"]="$tmp_ $rh_env_path_"
    exec_options["ENVIRONMENT_FILE"]="$tmpfile_"

    tmp_=""
    unset val
    val=$(resolve_item cfg "start_pre_script")
    if [[ $? == 0 ]] ;
    then
        if [ ! -z exec_options["START_PRE_SCRIPT"] ];
        then
            tmp_="$val"
        fi
    fi
    exec_options["START_PRE_SCRIPT"]="$tmp_"

    unset val
    val=$(resolve_item cfg "start_post_script")
    exec_options["START_POST_SCRIPT"]="$val"

    unset val
    val=$(resolve_item cfg "stop_pre_script")
    exec_options["STOP_PRE_SCRIPT"]="$val"

    unset val
    val=$(resolve_item cfg "stop_post_script")
    exec_options["STOP_POST_SCRIPT"]="$val"

    tmp_=""
    unset val
    val=$(resolve_item cfg "BACKGROUND")
    if [[ $? == 0 ]] ;
    then
        if check_true_value $val ;
        then
           exec_options["BACKGROUND"]=1
        else
           exec_options["BACKGROUND"]=0
        fi	
    fi

    return 0
}



rh_run_scripts() {
    # assume cfg and exec_options arrays are populated
    local script_="$1"
    local redirect_="${exec_options["REDIRECT"]}"
    if [[ $script_ ]]
    then
        if [[ -z $redirect ]]
        then
            redirect_=" &> /dev/null"
        fi
        if [[ -d $script_ ]] ;
        then
            SCRIPT_FILES=$(shopt -s nullglob dotglob; echo $script_/* )
            for script in ${SCRIPT_FILES}
            do
                echo "Running Script: $script"
                . $script $redirect_ 
            done
        elif [[ ! -z $script_ ]] 
        then
            . $script_ $redirect_ 
        fi
    fi
}

#
# Runs all the command line args $* in a background process
#
# requires exec_options is populated
#
rh_bg_cmd() {
    # assume exec_options and args are defined
    local bg_="${exec_options["BACKGROUND"]}"
    [[ ! $bg_  ]] && exec_options["BACKGROUND"]="true"
    [[ -z $bg_ ]] && exec_options["BACKGROUND"]="true"
    rh_cmd $*
}


#
# Runs all the command line args $* as a foreground process
#
# requires exec_options is populated
#
rh_fg_cmd() {
    # assume exec_options and args are defined
    local bg_="${exec_options["BACKGROUND"]}"
    [[ ! $bg_  ]] && exec_options["BACKGROUND"]="false"
    [[ -z $bg_ ]] && exec_options["BACKGROUND"]="false"
    rh_cmd $*
}


#
# Runs all the command line args $* as a foreground process, overrides
# redirected io to stdout
#
# requires exec_options is populated
#
rh_fg_nocap_cmd() {
    # assume exec_options and args are defined
    local bg_="${exec_options["BACKGROUND"]}"
    [[ ! $bg_  ]] && exec_options["BACKGROUND"]="false"
    [[ -z $bg_ ]] && exec_options["BACKGROUND"]="false"
    exec_options["NOCAPTURE"]="true"
    rh_cmd $*
}

# Runs a program as specified user/group
# 
# requires exec_options array to be populated
# Responds to the following settings in exec_options
# 
# USER - user id when running program 
# GROUP - group id then running program
# CGROUP - cgroup exec setup
# NICELEVEL - nice level command exec
# ULIMIT - ulimit command execution
# AFFINITY - numactl execution
# ENVIRONMENT - list of environment variables
# ENVIRONMENT_FILE - environment variables in a file to be sourced before running
#                    pre startup script and target program
# RUNDIR - directory to run command from
# ORB_CFG - set OMNIORB_CONFIG before running target program
# OUTPUT - file for redirect stdout and stderr 
# OUTPUT_REDIRECT - file descriptors to redirect to OUTPUT
# PIDFILE - capture background proces pid to file
# NOCAPTURE - ignore outfile and io redirection requests
# PERMISSIONS_START_ONLY - controls if START_PRE_SCRIPTS run as root or target user
# START_PRE_SCRIPT - file or directory of scripts to execute before running target program
# 
#
rh_cmd() {
        # assume exec_options and args are defined
	local user= pid_file= group=
	while [ "$1" != "${1##[-+]}" ]; do
	  case $1 in
	    '')    echo $"$0: Usage: rh_cmd {program}" "[arg1]..."
	           return 1;;
	    --user)
		   user=$2
		   shift 2
		   ;;
	    --user=?*)
	           user=${1#--user=}
		   shift
		   ;;
	    --group)
		   group=$2
		   shift 2
		   ;;
	    --group=?*)
	           group=${1#--group=}
		   shift
		   ;;
	    --pidfile)
		   pid_file=$2
		   shift 2
		   ;;
	    --pidfile=?*)
		   pid_file=${1#--pidfile=}
		   shift
		   ;;
	    *)     echo $"$0: Usage: rh_cmd [+/-nicelevel] {program}" "[arg1]..."
	           return 1;;
	  esac
	done
        
        local user_
        if [[ $user ]]
        then
            if [[ -z $user ]]
            then 
                user_="${exec_options["USER"]}"
            else
                user_="$user"
            fi
        else
            user_="${exec_options["USER"]}"
        fi

        local group_=""
        if [[ $group ]]
        then
            if [[ -z $group ]]
            then
                group_=""
            else
	        group_="-g $group"
            fi
        else
	    local g_="${exec_options["GROUP"]}"
            if [[ -z $g_ ]]
            then
	        group_=""
            else
	        group_="-g $g_"
            fi
	fi

	local cgroup_="${exec_options["CGROUP"]}"
	local nice_="${exec_options["NICELEVEL"]}"
	local ulimit_="${exec_options["ULIMIT"]}"
	local affinity_="${exec_options["AFFINITY"]}"

	local env_="${exec_options["ENVIRONMENT"]}"
	local env_file_="${exec_options["ENVIRONMENT_FILE"]}"
	local rundir_="${exec_options["RUNDIR"]}"
	local orb_cfg_="${exec_options["ORB_CFG"]}"

	local outfile_="${exec_options["OUTPUT"]}"
        [ -z $outfile_ ] && outfile_="/dev/null" 
        [ -z $pid_file ] && pid_file="${exec_options["PIDFILE"]}"

        local redirect_="2>&1"
	local nocap_="${exec_options["NOCAPTURE"]}"
        if [[ ! $nocap_ ]]
        then
            nocap_="false"
        else
            if check_true_value $nocap_ ;
            then
                redirect_=""
            fi
        fi

        if ! check_true_value $nocap_ ;
        then
            # handle redirect options
	    local redir_="${exec_options["OUTPUT_REDIRECT"]}"
            redir_=${redir_^^}
            # if stdout and stderr... then send to output file
            # otherwise send set one to output and not set one to /dev/null
            if [[ $redir_ =~ .*STDERR.* &&  $redir_ =~ .*STDOUT.* ]]
            then
                redirect_=">>$outfile_ 2>&1"
            elif [[ $redir_ =~ .*STDERR.* && ! $redir_ =~ .*STDOUT.* ]]
            then
                redirect_="2>>$outfile_ 1>/dev/null "
            elif [[ ! $redir_ =~ .*STDERR.* && $redir_ =~ .*STDOUT.* ]]
            then
                redirect_="2>/dev/null 1>>$outfile_ "
            else
                redirect_=">>$outfile_  2>&1 "
            fi
        fi
        exec_options["REDIRECT"]="$redirect_"

	env_cmd_=""
	if [[ $env_file_ ]]
        then
	    env_cmd_=" . $env_file_ ; "
	else
	    env_cmd_="$env_"
	fi

        local pre_script_="${exec_options["START_PRE_SCRIPT"]}"
        if [[ $pre_script_ ]]
        then
            if [[ ! -z $pre_script_ ]]
            then
                if [[ -d $pre_script_ ]];
                then
                   pre_script_="/etc/redhawk/init.d/rundir $pre_script_ $redirect_;"
                else
                    pre_script_=" . $pre_script_ $redirect_ ;"
                fi
            fi
        fi

	local pid_cap_
	local bg_=""
	local dm_="${exec_options["BACKGROUND"]}"
	if [[ $dm_ ]]
	then
            if check_false_value "$dm_" ;
            then
		bg_=";"
		pid_cap_=""
	    else
	        bg_="&"
                [[ ! $pid_file ]] && pid_file="/dev/null"
                [[ -z $pid_file ]] && pid_file="/dev/null"
	        pid_cap_="echo \$! > $pid_file"	
            fi
        else
            # default is background mode, make sure we have a pid file...
	    bg_="&"
            [[ ! $pid_file ]] && pid_file="/dev/null"
            [[ -z $pid_file ]] && pid_file="/dev/null"	    pid_cap_="echo \$! > $pid_file"	
        fi

        # check if we should run the pre start scripts as root or user
        local perm_start_="${exec_options["PERMISSIONS_START_ONLY"]}"
        if [[ $perm_start_ ]]
        then
            if check_true_value "$perm_start_" ;
            then
                # run all the scripts as current user
		( eval " $env_cmd_ $pre_script_ ")
		pre_script_=""

               # if redirect is on then need to open up permissions for other users
               [[ $outfile_ != "/dev/null" ]] && [[ -f "$outfile_" ]] && chmod guo+rw "$outfile_"
            fi
        fi

	[[ $_rh_debug_ ]] && echo " DM $dm_ BG ${exec_options["BACKGROUND"]}  <$bg_> "

        # if redirect is on then need to open up permissions for other users
	retval=0
	if [ -z "$user_" ]; 
	then
	    [[ $_rh_debug_ ]] && { echo "CMD (nouser): $cgroup_ $nice_  $ulimit_ cat $env_file_ $redirect_ ; $env_cmd_ $pre_script_ $rundir_ $orb_cfg_ $affinity_ $* $redirect_ $bg_ $pid_cap_" ; }
	    ($cgroup_ $nice_  $ulimit_ cat $env_file_ $redirect_ ; $env_cmd_ $pre_script_ $rundir_ $orb_cfg_ $affinity_ $* $redirect_ $bg_ $pid_cap_)
	    retval=$?
	else
	    [[ $_rh_debug_ ]] && { echo "CMD (user):  $cgroup_ $nice_ runuser -s /bin/bash  $group_ $user_ -c $ulimit_ cat $env_file_ $redirect_ ;  $env_cmd_ $pre_script_ $rundir_ $orb_cfg_ $affinity_ $* $redirect_ $bg_ $pid_cap_ " ;}
	    ($cgroup_ $nice_ runuser -s /bin/bash  $group_ $user_ -c  "$ulimit_ cat $env_file_ $redirect_ ;  $env_cmd_ $pre_script_ $rundir_ $orb_cfg_ $affinity_ $* $redirect_ $bg_ $pid_cap_ ")
	    retval=$?
	    #ub ($cgroup $nice su -s /bin/bash  $user -c "$ulimit_ cat $env_file_ $redirect_ ;  $env_cmd_ $pre_script_ $rundir_ $orb_cfg_ $affinity_ $* $redirect_ $bg_ $pid_cap_ ")
	fi

	local retain_="${exec_options["RETAIN_ENVIRONMENT"]}"
        ! check_true_value "$retain_" && [[ -f $env_file_ ]] && rm "$env_file_"

	return $retval

}


rh_clean_env() {
    local env_file_="${exec_options["ENVIRONMENT_FILE"]}"
    [[ -f $env_file_ ]] && rm "$env_file_"
}


